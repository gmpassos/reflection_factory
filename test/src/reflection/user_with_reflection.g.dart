//
// GENERATED CODE - DO NOT MODIFY BY HAND!
// BUILDER: reflection_factory/2.4.3
// BUILD COMMAND: dart run build_runner build
//

// coverage:ignore-file
// ignore_for_file: unused_element
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: camel_case_types
// ignore_for_file: camel_case_extensions
// ignore_for_file: unnecessary_const
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_type_check

part of '../user_with_reflection.dart';

typedef __TR<T> = TypeReflection<T>;
typedef __TI<T> = TypeInfo<T>;
typedef __PR = ParameterReflection;

mixin __ReflectionMixin {
  static final Version _version = Version.parse('2.4.3');

  Version get reflectionFactoryVersion => _version;

  List<Reflection> siblingsReflection() => _siblingsReflection();
}

// ignore: non_constant_identifier_names
TestAddressWithReflection TestAddressWithReflection$fromJson(
        Map<String, Object?> map) =>
    TestAddressWithReflection$reflection.staticInstance.fromJson(map);
// ignore: non_constant_identifier_names
TestAddressWithReflection TestAddressWithReflection$fromJsonEncoded(
        String jsonEncoded) =>
    TestAddressWithReflection$reflection.staticInstance
        .fromJsonEncoded(jsonEncoded);
// ignore: non_constant_identifier_names
TestCompanyWithReflection TestCompanyWithReflection$fromJson(
        Map<String, Object?> map) =>
    TestCompanyWithReflection$reflection.staticInstance.fromJson(map);
// ignore: non_constant_identifier_names
TestCompanyWithReflection TestCompanyWithReflection$fromJsonEncoded(
        String jsonEncoded) =>
    TestCompanyWithReflection$reflection.staticInstance
        .fromJsonEncoded(jsonEncoded);
// ignore: non_constant_identifier_names
TestDataWithReflection TestDataWithReflection$fromJson(
        Map<String, Object?> map) =>
    TestDataWithReflection$reflection.staticInstance.fromJson(map);
// ignore: non_constant_identifier_names
TestDataWithReflection TestDataWithReflection$fromJsonEncoded(
        String jsonEncoded) =>
    TestDataWithReflection$reflection.staticInstance
        .fromJsonEncoded(jsonEncoded);
// ignore: non_constant_identifier_names
TestDomainWithReflection TestDomainWithReflection$fromJson(
        Map<String, Object?> map) =>
    TestDomainWithReflection$reflection.staticInstance.fromJson(map);
// ignore: non_constant_identifier_names
TestDomainWithReflection TestDomainWithReflection$fromJsonEncoded(
        String jsonEncoded) =>
    TestDomainWithReflection$reflection.staticInstance
        .fromJsonEncoded(jsonEncoded);
// ignore: non_constant_identifier_names
TestEmpty TestEmpty$fromJson(Map<String, Object?> map) =>
    TestEmpty$reflection.staticInstance.fromJson(map);
// ignore: non_constant_identifier_names
TestEmpty TestEmpty$fromJsonEncoded(String jsonEncoded) =>
    TestEmpty$reflection.staticInstance.fromJsonEncoded(jsonEncoded);
// ignore: non_constant_identifier_names
TestEnumWithReflection? TestEnumWithReflection$from(Object? o) =>
    TestEnumWithReflection$reflection.staticInstance.from(o);
// ignore: non_constant_identifier_names
TestFranchiseWithReflection TestFranchiseWithReflection$fromJson(
        Map<String, Object?> map) =>
    TestFranchiseWithReflection$reflection.staticInstance.fromJson(map);
// ignore: non_constant_identifier_names
TestFranchiseWithReflection TestFranchiseWithReflection$fromJsonEncoded(
        String jsonEncoded) =>
    TestFranchiseWithReflection$reflection.staticInstance
        .fromJsonEncoded(jsonEncoded);
// ignore: non_constant_identifier_names
TestName TestName$fromJson(Map<String, Object?> map) =>
    TestName$reflection.staticInstance.fromJson(map);
// ignore: non_constant_identifier_names
TestName TestName$fromJsonEncoded(String jsonEncoded) =>
    TestName$reflection.staticInstance.fromJsonEncoded(jsonEncoded);
// ignore: non_constant_identifier_names
TestOpAWithReflection TestOpAWithReflection$fromJson(
        Map<String, Object?> map) =>
    TestOpAWithReflection$reflection.staticInstance.fromJson(map);
// ignore: non_constant_identifier_names
TestOpAWithReflection TestOpAWithReflection$fromJsonEncoded(
        String jsonEncoded) =>
    TestOpAWithReflection$reflection.staticInstance
        .fromJsonEncoded(jsonEncoded);
// ignore: non_constant_identifier_names
TestOpBWithReflection TestOpBWithReflection$fromJson(
        Map<String, Object?> map) =>
    TestOpBWithReflection$reflection.staticInstance.fromJson(map);
// ignore: non_constant_identifier_names
TestOpBWithReflection TestOpBWithReflection$fromJsonEncoded(
        String jsonEncoded) =>
    TestOpBWithReflection$reflection.staticInstance
        .fromJsonEncoded(jsonEncoded);
// ignore: non_constant_identifier_names
TestOpWithReflection TestOpWithReflection$fromJson(Map<String, Object?> map) =>
    TestOpWithReflection$reflection.staticInstance.fromJson(map);
// ignore: non_constant_identifier_names
TestOpWithReflection TestOpWithReflection$fromJsonEncoded(String jsonEncoded) =>
    TestOpWithReflection$reflection.staticInstance.fromJsonEncoded(jsonEncoded);
// ignore: non_constant_identifier_names
TestTransactionWithReflection TestTransactionWithReflection$fromJson(
        Map<String, Object?> map) =>
    TestTransactionWithReflection$reflection.staticInstance.fromJson(map);
// ignore: non_constant_identifier_names
TestTransactionWithReflection TestTransactionWithReflection$fromJsonEncoded(
        String jsonEncoded) =>
    TestTransactionWithReflection$reflection.staticInstance
        .fromJsonEncoded(jsonEncoded);
// ignore: non_constant_identifier_names
TestUserWithReflection TestUserWithReflection$fromJson(
        Map<String, Object?> map) =>
    TestUserWithReflection$reflection.staticInstance.fromJson(map);
// ignore: non_constant_identifier_names
TestUserWithReflection TestUserWithReflection$fromJsonEncoded(
        String jsonEncoded) =>
    TestUserWithReflection$reflection.staticInstance
        .fromJsonEncoded(jsonEncoded);

class TestAddressWithReflection$reflection
    extends ClassReflection<TestAddressWithReflection> with __ReflectionMixin {
  TestAddressWithReflection$reflection([TestAddressWithReflection? object])
      : this._(object);

  TestAddressWithReflection$reflection._([TestAddressWithReflection? object])
      : super(TestAddressWithReflection, r'TestAddressWithReflection', object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestAddressWithReflection$reflection withObject(
          [TestAddressWithReflection? obj]) =>
      TestAddressWithReflection$reflection(obj)..setupInternalsWith(this);

  static TestAddressWithReflection$reflection? _withoutObjectInstance;
  @override
  TestAddressWithReflection$reflection withoutObjectInstance() =>
      staticInstance;

  static TestAddressWithReflection$reflection get staticInstance =>
      _withoutObjectInstance ??= TestAddressWithReflection$reflection._();

  @override
  TestAddressWithReflection$reflection getStaticInstance() => staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestAddressWithReflection$reflection.staticInstance;
  }

  @override
  bool get hasDefaultConstructor => false;
  @override
  TestAddressWithReflection? createInstanceWithDefaultConstructor() => null;

  @override
  bool get hasEmptyConstructor => true;
  @override
  TestAddressWithReflection? createInstanceWithEmptyConstructor() =>
      TestAddressWithReflection.empty();
  @override
  bool get hasNoRequiredArgsConstructor => true;
  @override
  TestAddressWithReflection? createInstanceWithNoRequiredArgsConstructor() =>
      TestAddressWithReflection.empty();

  static const List<String> _constructorsNames = const <String>[
    'empty',
    'simple',
    'withCity'
  ];

  @override
  List<String> get constructorsNames => _constructorsNames;

  static final Map<String, ConstructorReflection<TestAddressWithReflection>>
      _constructors = {};

  @override
  ConstructorReflection<TestAddressWithReflection>? constructor(
      String constructorName) {
    var c = _constructors[constructorName];
    if (c != null) return c;
    c = _constructorImpl(constructorName);
    if (c == null) return null;
    _constructors[constructorName] = c;
    return c;
  }

  ConstructorReflection<TestAddressWithReflection>? _constructorImpl(
      String constructorName) {
    var lc = constructorName.trim().toLowerCase();

    switch (lc) {
      case 'simple':
        return ConstructorReflection<TestAddressWithReflection>(
            this,
            TestAddressWithReflection,
            'simple',
            () => (String state, {int? id}) =>
                TestAddressWithReflection.simple(state, id: id),
            const <__PR>[__PR(__TR.tString, 'state', false, true)],
            null,
            const <String, __PR>{'id': __PR(__TR.tInt, 'id', true, false)},
            null);
      case 'withcity':
        return ConstructorReflection<TestAddressWithReflection>(
            this,
            TestAddressWithReflection,
            'withCity',
            () => (String state, {String city = '', int? id}) =>
                TestAddressWithReflection.withCity(state, city: city, id: id),
            const <__PR>[__PR(__TR.tString, 'state', false, true)],
            null,
            const <String, __PR>{
              'city': __PR(__TR.tString, 'city', false, false, ''),
              'id': __PR(__TR.tInt, 'id', true, false)
            },
            const [JsonConstructor(mandatory: true)]);
      case 'empty':
        return ConstructorReflection<TestAddressWithReflection>(
            this,
            TestAddressWithReflection,
            'empty',
            () => () => TestAddressWithReflection.empty(),
            null,
            null,
            null,
            null);
      default:
        return null;
    }
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<Type> _supperTypes = const <Type>[];

  @override
  List<Type> get supperTypes => _supperTypes;

  @override
  bool get hasMethodToJson => true;

  @override
  Object? callMethodToJson([TestAddressWithReflection? obj]) {
    obj ??= object;
    return obj?.toJson();
  }

  static const List<String> _fieldsNames = const <String>[
    'city',
    'hashCode',
    'id',
    'state'
  ];

  @override
  List<String> get fieldsNames => _fieldsNames;

  static final Map<String, FieldReflection<TestAddressWithReflection, dynamic>>
      _fieldsNoObject = {};

  final Map<String, FieldReflection<TestAddressWithReflection, dynamic>>
      _fieldsObject = {};

  @override
  FieldReflection<TestAddressWithReflection, T>? field<T>(String fieldName,
      [TestAddressWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _fieldObjectImpl<T>(fieldName);
      } else {
        return _fieldNoObjectImpl<T>(fieldName);
      }
    } else if (identical(obj, object)) {
      return _fieldObjectImpl<T>(fieldName);
    }
    return _fieldNoObjectImpl<T>(fieldName)?.withObject(obj);
  }

  FieldReflection<TestAddressWithReflection, T>? _fieldNoObjectImpl<T>(
      String fieldName) {
    final f = _fieldsNoObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestAddressWithReflection, T>;
    }
    final f2 = _fieldImpl(fieldName, null);
    if (f2 == null) return null;
    _fieldsNoObject[fieldName] = f2;
    return f2 as FieldReflection<TestAddressWithReflection, T>;
  }

  FieldReflection<TestAddressWithReflection, T>? _fieldObjectImpl<T>(
      String fieldName) {
    final f = _fieldsObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestAddressWithReflection, T>;
    }
    var f2 = _fieldNoObjectImpl<T>(fieldName);
    if (f2 == null) return null;
    f2 = f2.withObject(object!);
    _fieldsObject[fieldName] = f2;
    return f2;
  }

  FieldReflection<TestAddressWithReflection, dynamic>? _fieldImpl(
      String fieldName, TestAddressWithReflection? obj) {
    obj ??= object;

    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'id':
        return FieldReflection<TestAddressWithReflection, int?>(
          this,
          TestAddressWithReflection,
          __TR.tInt,
          'id',
          true,
          (o) => () => o!.id,
          (o) => (v) => o!.id = v,
          obj,
          false,
        );
      case 'state':
        return FieldReflection<TestAddressWithReflection, String>(
          this,
          TestAddressWithReflection,
          __TR.tString,
          'state',
          false,
          (o) => () => o!.state,
          null,
          obj,
          true,
        );
      case 'city':
        return FieldReflection<TestAddressWithReflection, String>(
          this,
          TestAddressWithReflection,
          __TR.tString,
          'city',
          false,
          (o) => () => o!.city,
          null,
          obj,
          true,
        );
      case 'hashcode':
        return FieldReflection<TestAddressWithReflection, int>(
          this,
          TestAddressWithReflection,
          __TR.tInt,
          'hashCode',
          false,
          (o) => () => o!.hashCode,
          null,
          obj,
          false,
          const [override],
        );
      default:
        return null;
    }
  }

  @override
  Map<String, dynamic> getFieldsValues(TestAddressWithReflection? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'id': obj?.id,
      'state': obj?.state,
      'city': obj?.city,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  static const List<String> _staticFieldsNames = const <String>[];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  @override
  StaticFieldReflection<TestAddressWithReflection, T>? staticField<T>(
          String fieldName) =>
      null;

  static const List<String> _methodsNames = const <String>[
    'toJson',
    'toString'
  ];

  @override
  List<String> get methodsNames => _methodsNames;

  static final Map<String, MethodReflection<TestAddressWithReflection, dynamic>>
      _methodsNoObject = {};

  final Map<String, MethodReflection<TestAddressWithReflection, dynamic>>
      _methodsObject = {};

  @override
  MethodReflection<TestAddressWithReflection, R>? method<R>(String methodName,
      [TestAddressWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _methodObjectImpl<R>(methodName);
      } else {
        return _methodNoObjectImpl<R>(methodName);
      }
    } else if (identical(obj, object)) {
      return _methodObjectImpl<R>(methodName);
    }
    return _methodNoObjectImpl<R>(methodName)?.withObject(obj);
  }

  MethodReflection<TestAddressWithReflection, R>? _methodNoObjectImpl<R>(
      String methodName) {
    final m = _methodsNoObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestAddressWithReflection, R>;
    }
    final m2 = _methodImpl(methodName, null);
    if (m2 == null) return null;
    _methodsNoObject[methodName] = m2;
    return m2 as MethodReflection<TestAddressWithReflection, R>;
  }

  MethodReflection<TestAddressWithReflection, R>? _methodObjectImpl<R>(
      String methodName) {
    final m = _methodsObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestAddressWithReflection, R>;
    }
    var m2 = _methodNoObjectImpl<R>(methodName);
    if (m2 == null) return null;
    m2 = m2.withObject(object!);
    _methodsObject[methodName] = m2;
    return m2;
  }

  MethodReflection<TestAddressWithReflection, dynamic>? _methodImpl(
      String methodName, TestAddressWithReflection? obj) {
    obj ??= object;

    var lc = methodName.trim().toLowerCase();

    switch (lc) {
      case 'tojson':
        return MethodReflection<TestAddressWithReflection,
                Map<String, dynamic>>(
            this,
            TestAddressWithReflection,
            'toJson',
            __TR.tMapStringDynamic,
            false,
            (o) => o!.toJson,
            obj,
            null,
            null,
            null,
            null);
      case 'tostring':
        return MethodReflection<TestAddressWithReflection, String>(
            this,
            TestAddressWithReflection,
            'toString',
            __TR.tString,
            false,
            (o) => o!.toString,
            obj,
            null,
            null,
            null,
            const [override]);
      default:
        return null;
    }
  }

  static const List<String> _staticMethodsNames = const <String>[];

  @override
  List<String> get staticMethodsNames => _staticMethodsNames;

  @override
  StaticMethodReflection<TestAddressWithReflection, R>? staticMethod<R>(
          String methodName) =>
      null;
}

class TestCompanyWithReflection$reflection
    extends ClassReflection<TestCompanyWithReflection> with __ReflectionMixin {
  static final Expando<TestCompanyWithReflection$reflection>
      _objectReflections = Expando();

  factory TestCompanyWithReflection$reflection(
      [TestCompanyWithReflection? object]) {
    if (object == null) return staticInstance;
    return _objectReflections[object] ??=
        TestCompanyWithReflection$reflection._(object);
  }

  TestCompanyWithReflection$reflection._([TestCompanyWithReflection? object])
      : super(TestCompanyWithReflection, r'TestCompanyWithReflection', object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestCompanyWithReflection$reflection withObject(
          [TestCompanyWithReflection? obj]) =>
      TestCompanyWithReflection$reflection(obj)..setupInternalsWith(this);

  static TestCompanyWithReflection$reflection? _withoutObjectInstance;
  @override
  TestCompanyWithReflection$reflection withoutObjectInstance() =>
      staticInstance;

  static TestCompanyWithReflection$reflection get staticInstance =>
      _withoutObjectInstance ??= TestCompanyWithReflection$reflection._();

  @override
  TestCompanyWithReflection$reflection getStaticInstance() => staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestCompanyWithReflection$reflection.staticInstance;
  }

  @override
  bool get hasDefaultConstructor => false;
  @override
  TestCompanyWithReflection? createInstanceWithDefaultConstructor() => null;

  @override
  bool get hasEmptyConstructor => false;
  @override
  TestCompanyWithReflection? createInstanceWithEmptyConstructor() => null;
  @override
  bool get hasNoRequiredArgsConstructor => false;
  @override
  TestCompanyWithReflection? createInstanceWithNoRequiredArgsConstructor() =>
      null;

  static const List<String> _constructorsNames = const <String>[
    '',
    'noBranches'
  ];

  @override
  List<String> get constructorsNames => _constructorsNames;

  static final Map<String, ConstructorReflection<TestCompanyWithReflection>>
      _constructors = {};

  @override
  ConstructorReflection<TestCompanyWithReflection>? constructor(
      String constructorName) {
    var c = _constructors[constructorName];
    if (c != null) return c;
    c = _constructorImpl(constructorName);
    if (c == null) return null;
    _constructors[constructorName] = c;
    return c;
  }

  ConstructorReflection<TestCompanyWithReflection>? _constructorImpl(
      String constructorName) {
    var lc = constructorName.trim().toLowerCase();

    switch (lc) {
      case '':
        return ConstructorReflection<TestCompanyWithReflection>(
            this,
            TestCompanyWithReflection,
            '',
            () => (String name, TestAddressWithReflection? mainAddress,
                    {List<TestAddressWithReflection> extraAddresses =
                        const <TestAddressWithReflection>[],
                    List<TestAddressWithReflection> branchesAddresses =
                        const <TestAddressWithReflection>[],
                    List<String> extraNames = const <String>[]}) =>
                TestCompanyWithReflection(name, mainAddress,
                    extraAddresses: extraAddresses,
                    branchesAddresses: branchesAddresses,
                    extraNames: extraNames),
            const <__PR>[
              __PR(__TR.tString, 'name', false, true),
              __PR(__TR<TestAddressWithReflection>(TestAddressWithReflection),
                  'mainAddress', true, true)
            ],
            null,
            const <String, __PR>{
              'branchesAddresses': __PR(
                  __TR<List<TestAddressWithReflection>>(List, <__TR>[
                    __TR<TestAddressWithReflection>(TestAddressWithReflection)
                  ]),
                  'branchesAddresses',
                  false,
                  false,
                  const <TestAddressWithReflection>[]),
              'extraAddresses': __PR(
                  __TR<List<TestAddressWithReflection>>(List, <__TR>[
                    __TR<TestAddressWithReflection>(TestAddressWithReflection)
                  ]),
                  'extraAddresses',
                  false,
                  false,
                  const <TestAddressWithReflection>[]),
              'extraNames': __PR(__TR.tListString, 'extraNames', false, false,
                  const <String>[])
            },
            null);
      case 'nobranches':
        return ConstructorReflection<TestCompanyWithReflection>(
            this,
            TestCompanyWithReflection,
            'noBranches',
            () => (String name, TestAddressWithReflection? mainAddress,
                    {List<TestAddressWithReflection> extraAddresses =
                        const <TestAddressWithReflection>[],
                    List<String> extraNames = const <String>[]}) =>
                TestCompanyWithReflection.noBranches(name, mainAddress,
                    extraAddresses: extraAddresses, extraNames: extraNames),
            const <__PR>[
              __PR(__TR.tString, 'name', false, true),
              __PR(__TR<TestAddressWithReflection>(TestAddressWithReflection),
                  'mainAddress', true, true)
            ],
            null,
            const <String, __PR>{
              'extraAddresses': __PR(
                  __TR<List<TestAddressWithReflection>>(List, <__TR>[
                    __TR<TestAddressWithReflection>(TestAddressWithReflection)
                  ]),
                  'extraAddresses',
                  false,
                  false,
                  const <TestAddressWithReflection>[]),
              'extraNames': __PR(__TR.tListString, 'extraNames', false, false,
                  const <String>[])
            },
            null);
      default:
        return null;
    }
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<Type> _supperTypes = const <Type>[];

  @override
  List<Type> get supperTypes => _supperTypes;

  @override
  bool get hasMethodToJson => false;

  @override
  Object? callMethodToJson([TestCompanyWithReflection? obj]) => null;

  static const List<String> _fieldsNames = const <String>[
    'branchesAddresses',
    'extraAddresses',
    'extraNames',
    'hashCode',
    'local',
    'mainAddress',
    'name'
  ];

  @override
  List<String> get fieldsNames => _fieldsNames;

  static final Map<String, FieldReflection<TestCompanyWithReflection, dynamic>>
      _fieldsNoObject = {};

  final Map<String, FieldReflection<TestCompanyWithReflection, dynamic>>
      _fieldsObject = {};

  @override
  FieldReflection<TestCompanyWithReflection, T>? field<T>(String fieldName,
      [TestCompanyWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _fieldObjectImpl<T>(fieldName);
      } else {
        return _fieldNoObjectImpl<T>(fieldName);
      }
    } else if (identical(obj, object)) {
      return _fieldObjectImpl<T>(fieldName);
    }
    return _fieldNoObjectImpl<T>(fieldName)?.withObject(obj);
  }

  FieldReflection<TestCompanyWithReflection, T>? _fieldNoObjectImpl<T>(
      String fieldName) {
    final f = _fieldsNoObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestCompanyWithReflection, T>;
    }
    final f2 = _fieldImpl(fieldName, null);
    if (f2 == null) return null;
    _fieldsNoObject[fieldName] = f2;
    return f2 as FieldReflection<TestCompanyWithReflection, T>;
  }

  FieldReflection<TestCompanyWithReflection, T>? _fieldObjectImpl<T>(
      String fieldName) {
    final f = _fieldsObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestCompanyWithReflection, T>;
    }
    var f2 = _fieldNoObjectImpl<T>(fieldName);
    if (f2 == null) return null;
    f2 = f2.withObject(object!);
    _fieldsObject[fieldName] = f2;
    return f2;
  }

  FieldReflection<TestCompanyWithReflection, dynamic>? _fieldImpl(
      String fieldName, TestCompanyWithReflection? obj) {
    obj ??= object;

    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'name':
        return FieldReflection<TestCompanyWithReflection, String>(
          this,
          TestCompanyWithReflection,
          __TR.tString,
          'name',
          false,
          (o) => () => o!.name,
          null,
          obj,
          true,
        );
      case 'mainaddress':
        return FieldReflection<TestCompanyWithReflection,
            TestAddressWithReflection?>(
          this,
          TestCompanyWithReflection,
          __TR<TestAddressWithReflection>(TestAddressWithReflection),
          'mainAddress',
          true,
          (o) => () => o!.mainAddress,
          (o) => (v) => o!.mainAddress = v,
          obj,
          false,
        );
      case 'extranames':
        return FieldReflection<TestCompanyWithReflection, List<String>>(
          this,
          TestCompanyWithReflection,
          __TR.tListString,
          'extraNames',
          false,
          (o) => () => o!.extraNames,
          null,
          obj,
          true,
        );
      case 'branchesaddresses':
        return FieldReflection<TestCompanyWithReflection,
            List<TestAddressWithReflection>>(
          this,
          TestCompanyWithReflection,
          __TR<List<TestAddressWithReflection>>(List, <__TR>[
            __TR<TestAddressWithReflection>(TestAddressWithReflection)
          ]),
          'branchesAddresses',
          false,
          (o) => () => o!.branchesAddresses,
          (o) => (v) => o!.branchesAddresses = v,
          obj,
          false,
        );
      case 'extraaddresses':
        return FieldReflection<TestCompanyWithReflection,
            List<TestAddressWithReflection>>(
          this,
          TestCompanyWithReflection,
          __TR<List<TestAddressWithReflection>>(List, <__TR>[
            __TR<TestAddressWithReflection>(TestAddressWithReflection)
          ]),
          'extraAddresses',
          false,
          (o) => () => o!.extraAddresses,
          (o) => (v) => o!.extraAddresses = v,
          obj,
          false,
        );
      case 'local':
        return FieldReflection<TestCompanyWithReflection, bool>(
          this,
          TestCompanyWithReflection,
          __TR.tBool,
          'local',
          false,
          (o) => () => o!.local,
          (o) => (v) => o!.local = v,
          obj,
          false,
          const [JsonField.hidden()],
        );
      case 'hashcode':
        return FieldReflection<TestCompanyWithReflection, int>(
          this,
          TestCompanyWithReflection,
          __TR.tInt,
          'hashCode',
          false,
          (o) => () => o!.hashCode,
          null,
          obj,
          false,
          const [override],
        );
      default:
        return null;
    }
  }

  @override
  Map<String, dynamic> getFieldsValues(TestCompanyWithReflection? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'name': obj?.name,
      'mainAddress': obj?.mainAddress,
      'extraNames': obj?.extraNames,
      'branchesAddresses': obj?.branchesAddresses,
      'extraAddresses': obj?.extraAddresses,
      'local': obj?.local,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  @override
  Map<String, dynamic> getJsonFieldsVisibleValues(
      TestCompanyWithReflection? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'name': obj?.name,
      'mainAddress': obj?.mainAddress,
      'extraNames': obj?.extraNames,
      'branchesAddresses': obj?.branchesAddresses,
      'extraAddresses': obj?.extraAddresses,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  static const List<String> _staticFieldsNames = const <String>[];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  @override
  StaticFieldReflection<TestCompanyWithReflection, T>? staticField<T>(
          String fieldName) =>
      null;

  static const List<String> _methodsNames = const <String>['toString'];

  @override
  List<String> get methodsNames => _methodsNames;

  static final Map<String, MethodReflection<TestCompanyWithReflection, dynamic>>
      _methodsNoObject = {};

  final Map<String, MethodReflection<TestCompanyWithReflection, dynamic>>
      _methodsObject = {};

  @override
  MethodReflection<TestCompanyWithReflection, R>? method<R>(String methodName,
      [TestCompanyWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _methodObjectImpl<R>(methodName);
      } else {
        return _methodNoObjectImpl<R>(methodName);
      }
    } else if (identical(obj, object)) {
      return _methodObjectImpl<R>(methodName);
    }
    return _methodNoObjectImpl<R>(methodName)?.withObject(obj);
  }

  MethodReflection<TestCompanyWithReflection, R>? _methodNoObjectImpl<R>(
      String methodName) {
    final m = _methodsNoObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestCompanyWithReflection, R>;
    }
    final m2 = _methodImpl(methodName, null);
    if (m2 == null) return null;
    _methodsNoObject[methodName] = m2;
    return m2 as MethodReflection<TestCompanyWithReflection, R>;
  }

  MethodReflection<TestCompanyWithReflection, R>? _methodObjectImpl<R>(
      String methodName) {
    final m = _methodsObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestCompanyWithReflection, R>;
    }
    var m2 = _methodNoObjectImpl<R>(methodName);
    if (m2 == null) return null;
    m2 = m2.withObject(object!);
    _methodsObject[methodName] = m2;
    return m2;
  }

  MethodReflection<TestCompanyWithReflection, dynamic>? _methodImpl(
      String methodName, TestCompanyWithReflection? obj) {
    obj ??= object;

    var lc = methodName.trim().toLowerCase();

    switch (lc) {
      case 'tostring':
        return MethodReflection<TestCompanyWithReflection, String>(
            this,
            TestCompanyWithReflection,
            'toString',
            __TR.tString,
            false,
            (o) => o!.toString,
            obj,
            null,
            null,
            null,
            const [override]);
      default:
        return null;
    }
  }

  static const List<String> _staticMethodsNames = const <String>[];

  @override
  List<String> get staticMethodsNames => _staticMethodsNames;

  @override
  StaticMethodReflection<TestCompanyWithReflection, R>? staticMethod<R>(
          String methodName) =>
      null;
}

class TestDataWithReflection$reflection
    extends ClassReflection<TestDataWithReflection> with __ReflectionMixin {
  static final Expando<TestDataWithReflection$reflection> _objectReflections =
      Expando();

  factory TestDataWithReflection$reflection([TestDataWithReflection? object]) {
    if (object == null) return staticInstance;
    return _objectReflections[object] ??=
        TestDataWithReflection$reflection._(object);
  }

  TestDataWithReflection$reflection._([TestDataWithReflection? object])
      : super(TestDataWithReflection, r'TestDataWithReflection', object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestDataWithReflection$reflection withObject([TestDataWithReflection? obj]) =>
      TestDataWithReflection$reflection(obj)..setupInternalsWith(this);

  static TestDataWithReflection$reflection? _withoutObjectInstance;
  @override
  TestDataWithReflection$reflection withoutObjectInstance() => staticInstance;

  static TestDataWithReflection$reflection get staticInstance =>
      _withoutObjectInstance ??= TestDataWithReflection$reflection._();

  @override
  TestDataWithReflection$reflection getStaticInstance() => staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestDataWithReflection$reflection.staticInstance;
  }

  @override
  bool get hasDefaultConstructor => false;
  @override
  TestDataWithReflection? createInstanceWithDefaultConstructor() => null;

  @override
  bool get hasEmptyConstructor => false;
  @override
  TestDataWithReflection? createInstanceWithEmptyConstructor() => null;
  @override
  bool get hasNoRequiredArgsConstructor => false;
  @override
  TestDataWithReflection? createInstanceWithNoRequiredArgsConstructor() => null;

  static const List<String> _constructorsNames = const <String>[''];

  @override
  List<String> get constructorsNames => _constructorsNames;

  static final Map<String, ConstructorReflection<TestDataWithReflection>>
      _constructors = {};

  @override
  ConstructorReflection<TestDataWithReflection>? constructor(
      String constructorName) {
    var c = _constructors[constructorName];
    if (c != null) return c;
    c = _constructorImpl(constructorName);
    if (c == null) return null;
    _constructors[constructorName] = c;
    return c;
  }

  ConstructorReflection<TestDataWithReflection>? _constructorImpl(
      String constructorName) {
    var lc = constructorName.trim().toLowerCase();

    switch (lc) {
      case '':
        return ConstructorReflection<TestDataWithReflection>(
            this,
            TestDataWithReflection,
            '',
            () => (String name, Uint8List bytes,
                    {BigInt? id, TestDomainWithReflection? domain}) =>
                TestDataWithReflection(name, bytes, id: id, domain: domain),
            const <__PR>[
              __PR(__TR.tString, 'name', false, true),
              __PR(__TR<Uint8List>(Uint8List), 'bytes', false, true)
            ],
            null,
            const <String, __PR>{
              'domain': __PR(
                  __TR<TestDomainWithReflection>(TestDomainWithReflection),
                  'domain',
                  true,
                  false),
              'id': __PR(__TR.tBigInt, 'id', true, false)
            },
            null);
      default:
        return null;
    }
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<Type> _supperTypes = const <Type>[];

  @override
  List<Type> get supperTypes => _supperTypes;

  @override
  bool get hasMethodToJson => false;

  @override
  Object? callMethodToJson([TestDataWithReflection? obj]) => null;

  static const List<String> _fieldsNames = const <String>[
    'bytes',
    'domain',
    'hashCode',
    'id',
    'name'
  ];

  @override
  List<String> get fieldsNames => _fieldsNames;

  static final Map<String, FieldReflection<TestDataWithReflection, dynamic>>
      _fieldsNoObject = {};

  final Map<String, FieldReflection<TestDataWithReflection, dynamic>>
      _fieldsObject = {};

  @override
  FieldReflection<TestDataWithReflection, T>? field<T>(String fieldName,
      [TestDataWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _fieldObjectImpl<T>(fieldName);
      } else {
        return _fieldNoObjectImpl<T>(fieldName);
      }
    } else if (identical(obj, object)) {
      return _fieldObjectImpl<T>(fieldName);
    }
    return _fieldNoObjectImpl<T>(fieldName)?.withObject(obj);
  }

  FieldReflection<TestDataWithReflection, T>? _fieldNoObjectImpl<T>(
      String fieldName) {
    final f = _fieldsNoObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestDataWithReflection, T>;
    }
    final f2 = _fieldImpl(fieldName, null);
    if (f2 == null) return null;
    _fieldsNoObject[fieldName] = f2;
    return f2 as FieldReflection<TestDataWithReflection, T>;
  }

  FieldReflection<TestDataWithReflection, T>? _fieldObjectImpl<T>(
      String fieldName) {
    final f = _fieldsObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestDataWithReflection, T>;
    }
    var f2 = _fieldNoObjectImpl<T>(fieldName);
    if (f2 == null) return null;
    f2 = f2.withObject(object!);
    _fieldsObject[fieldName] = f2;
    return f2;
  }

  FieldReflection<TestDataWithReflection, dynamic>? _fieldImpl(
      String fieldName, TestDataWithReflection? obj) {
    obj ??= object;

    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'name':
        return FieldReflection<TestDataWithReflection, String>(
          this,
          TestDataWithReflection,
          __TR.tString,
          'name',
          false,
          (o) => () => o!.name,
          null,
          obj,
          true,
        );
      case 'id':
        return FieldReflection<TestDataWithReflection, BigInt>(
          this,
          TestDataWithReflection,
          __TR.tBigInt,
          'id',
          false,
          (o) => () => o!.id,
          (o) => (v) => o!.id = v,
          obj,
          false,
        );
      case 'bytes':
        return FieldReflection<TestDataWithReflection, Uint8List>(
          this,
          TestDataWithReflection,
          __TR<Uint8List>(Uint8List),
          'bytes',
          false,
          (o) => () => o!.bytes,
          (o) => (v) => o!.bytes = v,
          obj,
          false,
        );
      case 'domain':
        return FieldReflection<TestDataWithReflection,
            TestDomainWithReflection?>(
          this,
          TestDataWithReflection,
          __TR<TestDomainWithReflection>(TestDomainWithReflection),
          'domain',
          true,
          (o) => () => o!.domain,
          (o) => (v) => o!.domain = v,
          obj,
          false,
        );
      case 'hashcode':
        return FieldReflection<TestDataWithReflection, int>(
          this,
          TestDataWithReflection,
          __TR.tInt,
          'hashCode',
          false,
          (o) => () => o!.hashCode,
          null,
          obj,
          false,
          const [override],
        );
      default:
        return null;
    }
  }

  @override
  Map<String, dynamic> getFieldsValues(TestDataWithReflection? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'name': obj?.name,
      'id': obj?.id,
      'bytes': obj?.bytes,
      'domain': obj?.domain,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  static const List<String> _staticFieldsNames = const <String>[];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  @override
  StaticFieldReflection<TestDataWithReflection, T>? staticField<T>(
          String fieldName) =>
      null;

  static const List<String> _methodsNames = const <String>[];

  @override
  List<String> get methodsNames => _methodsNames;

  @override
  MethodReflection<TestDataWithReflection, R>? method<R>(String methodName,
          [TestDataWithReflection? obj]) =>
      null;
  static const List<String> _staticMethodsNames = const <String>[];

  @override
  List<String> get staticMethodsNames => _staticMethodsNames;

  @override
  StaticMethodReflection<TestDataWithReflection, R>? staticMethod<R>(
          String methodName) =>
      null;
}

class TestDomainWithReflection$reflection
    extends ClassReflection<TestDomainWithReflection> with __ReflectionMixin {
  static final Expando<TestDomainWithReflection$reflection> _objectReflections =
      Expando();

  factory TestDomainWithReflection$reflection(
      [TestDomainWithReflection? object]) {
    if (object == null) return staticInstance;
    return _objectReflections[object] ??=
        TestDomainWithReflection$reflection._(object);
  }

  TestDomainWithReflection$reflection._([TestDomainWithReflection? object])
      : super(TestDomainWithReflection, r'TestDomainWithReflection', object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestDomainWithReflection$reflection withObject(
          [TestDomainWithReflection? obj]) =>
      TestDomainWithReflection$reflection(obj)..setupInternalsWith(this);

  static TestDomainWithReflection$reflection? _withoutObjectInstance;
  @override
  TestDomainWithReflection$reflection withoutObjectInstance() => staticInstance;

  static TestDomainWithReflection$reflection get staticInstance =>
      _withoutObjectInstance ??= TestDomainWithReflection$reflection._();

  @override
  TestDomainWithReflection$reflection getStaticInstance() => staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestDomainWithReflection$reflection.staticInstance;
  }

  @override
  bool get hasDefaultConstructor => false;
  @override
  TestDomainWithReflection? createInstanceWithDefaultConstructor() => null;

  @override
  bool get hasEmptyConstructor => false;
  @override
  TestDomainWithReflection? createInstanceWithEmptyConstructor() => null;
  @override
  bool get hasNoRequiredArgsConstructor => false;
  @override
  TestDomainWithReflection? createInstanceWithNoRequiredArgsConstructor() =>
      null;

  static const List<String> _constructorsNames = const <String>[
    '',
    'named',
    'parse'
  ];

  @override
  List<String> get constructorsNames => _constructorsNames;

  static final Map<String, ConstructorReflection<TestDomainWithReflection>>
      _constructors = {};

  @override
  ConstructorReflection<TestDomainWithReflection>? constructor(
      String constructorName) {
    var c = _constructors[constructorName];
    if (c != null) return c;
    c = _constructorImpl(constructorName);
    if (c == null) return null;
    _constructors[constructorName] = c;
    return c;
  }

  ConstructorReflection<TestDomainWithReflection>? _constructorImpl(
      String constructorName) {
    var lc = constructorName.trim().toLowerCase();

    switch (lc) {
      case '':
        return ConstructorReflection<TestDomainWithReflection>(
            this,
            TestDomainWithReflection,
            '',
            () => (String name, String suffix,
                    [DomainFunction? domainFunction,
                    bool Function()? extraFunction]) =>
                TestDomainWithReflection(
                    name, suffix, domainFunction, extraFunction),
            const <__PR>[
              __PR(__TR.tString, 'name', false, true),
              __PR(__TR.tString, 'suffix', false, true)
            ],
            const <__PR>[
              __PR(__TR<DomainFunction>(DomainFunction), 'domainFunction', true,
                  false),
              __PR(__TR.tFunction, 'extraFunction', true, false)
            ],
            null,
            null);
      case 'named':
        return ConstructorReflection<TestDomainWithReflection>(
            this,
            TestDomainWithReflection,
            'named',
            () => (
                    {required String name,
                    String suffix = 'net',
                    DomainFunction? domainFunction,
                    bool Function()? extraFunction}) =>
                TestDomainWithReflection.named(
                    name: name,
                    suffix: suffix,
                    domainFunction: domainFunction,
                    extraFunction: extraFunction),
            null,
            null,
            const <String, __PR>{
              'domainFunction': __PR(__TR<DomainFunction>(DomainFunction),
                  'domainFunction', true, false),
              'extraFunction':
                  __PR(__TR.tFunction, 'extraFunction', true, false),
              'name': __PR(__TR.tString, 'name', false, true),
              'suffix': __PR(__TR.tString, 'suffix', false, false, 'net')
            },
            null);
      case 'parse':
        return ConstructorReflection<TestDomainWithReflection>(
            this,
            TestDomainWithReflection,
            'parse',
            () => (String s) => TestDomainWithReflection.parse(s),
            const <__PR>[__PR(__TR.tString, 's', false, true)],
            null,
            null,
            null);
      default:
        return null;
    }
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<Type> _supperTypes = const <Type>[];

  @override
  List<Type> get supperTypes => _supperTypes;

  @override
  bool get hasMethodToJson => true;

  @override
  Object? callMethodToJson([TestDomainWithReflection? obj]) {
    obj ??= object;
    return obj?.toJson();
  }

  static const List<String> _fieldsNames = const <String>[
    'domainFunction',
    'extraFunction',
    'hashCode',
    'name',
    'suffix'
  ];

  @override
  List<String> get fieldsNames => _fieldsNames;

  static final Map<String, FieldReflection<TestDomainWithReflection, dynamic>>
      _fieldsNoObject = {};

  final Map<String, FieldReflection<TestDomainWithReflection, dynamic>>
      _fieldsObject = {};

  @override
  FieldReflection<TestDomainWithReflection, T>? field<T>(String fieldName,
      [TestDomainWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _fieldObjectImpl<T>(fieldName);
      } else {
        return _fieldNoObjectImpl<T>(fieldName);
      }
    } else if (identical(obj, object)) {
      return _fieldObjectImpl<T>(fieldName);
    }
    return _fieldNoObjectImpl<T>(fieldName)?.withObject(obj);
  }

  FieldReflection<TestDomainWithReflection, T>? _fieldNoObjectImpl<T>(
      String fieldName) {
    final f = _fieldsNoObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestDomainWithReflection, T>;
    }
    final f2 = _fieldImpl(fieldName, null);
    if (f2 == null) return null;
    _fieldsNoObject[fieldName] = f2;
    return f2 as FieldReflection<TestDomainWithReflection, T>;
  }

  FieldReflection<TestDomainWithReflection, T>? _fieldObjectImpl<T>(
      String fieldName) {
    final f = _fieldsObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestDomainWithReflection, T>;
    }
    var f2 = _fieldNoObjectImpl<T>(fieldName);
    if (f2 == null) return null;
    f2 = f2.withObject(object!);
    _fieldsObject[fieldName] = f2;
    return f2;
  }

  FieldReflection<TestDomainWithReflection, dynamic>? _fieldImpl(
      String fieldName, TestDomainWithReflection? obj) {
    obj ??= object;

    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'name':
        return FieldReflection<TestDomainWithReflection, String>(
          this,
          TestDomainWithReflection,
          __TR.tString,
          'name',
          false,
          (o) => () => o!.name,
          null,
          obj,
          true,
        );
      case 'suffix':
        return FieldReflection<TestDomainWithReflection, String>(
          this,
          TestDomainWithReflection,
          __TR.tString,
          'suffix',
          false,
          (o) => () => o!.suffix,
          null,
          obj,
          true,
        );
      case 'domainfunction':
        return FieldReflection<TestDomainWithReflection, DomainFunction?>(
          this,
          TestDomainWithReflection,
          __TR<DomainFunction>(DomainFunction),
          'domainFunction',
          true,
          (o) => () => o!.domainFunction,
          null,
          obj,
          true,
        );
      case 'extrafunction':
        return FieldReflection<TestDomainWithReflection, bool Function()?>(
          this,
          TestDomainWithReflection,
          __TR.tFunction,
          'extraFunction',
          true,
          (o) => () => o!.extraFunction,
          null,
          obj,
          true,
        );
      case 'hashcode':
        return FieldReflection<TestDomainWithReflection, int>(
          this,
          TestDomainWithReflection,
          __TR.tInt,
          'hashCode',
          false,
          (o) => () => o!.hashCode,
          null,
          obj,
          false,
          const [override],
        );
      default:
        return null;
    }
  }

  @override
  Map<String, dynamic> getFieldsValues(TestDomainWithReflection? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'name': obj?.name,
      'suffix': obj?.suffix,
      'domainFunction': obj?.domainFunction,
      'extraFunction': obj?.extraFunction,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  static const List<String> _staticFieldsNames = const <String>[];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  @override
  StaticFieldReflection<TestDomainWithReflection, T>? staticField<T>(
          String fieldName) =>
      null;

  static const List<String> _methodsNames = const <String>[
    'toJson',
    'toString',
    'typedFunction'
  ];

  @override
  List<String> get methodsNames => _methodsNames;

  static final Map<String, MethodReflection<TestDomainWithReflection, dynamic>>
      _methodsNoObject = {};

  final Map<String, MethodReflection<TestDomainWithReflection, dynamic>>
      _methodsObject = {};

  @override
  MethodReflection<TestDomainWithReflection, R>? method<R>(String methodName,
      [TestDomainWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _methodObjectImpl<R>(methodName);
      } else {
        return _methodNoObjectImpl<R>(methodName);
      }
    } else if (identical(obj, object)) {
      return _methodObjectImpl<R>(methodName);
    }
    return _methodNoObjectImpl<R>(methodName)?.withObject(obj);
  }

  MethodReflection<TestDomainWithReflection, R>? _methodNoObjectImpl<R>(
      String methodName) {
    final m = _methodsNoObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestDomainWithReflection, R>;
    }
    final m2 = _methodImpl(methodName, null);
    if (m2 == null) return null;
    _methodsNoObject[methodName] = m2;
    return m2 as MethodReflection<TestDomainWithReflection, R>;
  }

  MethodReflection<TestDomainWithReflection, R>? _methodObjectImpl<R>(
      String methodName) {
    final m = _methodsObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestDomainWithReflection, R>;
    }
    var m2 = _methodNoObjectImpl<R>(methodName);
    if (m2 == null) return null;
    m2 = m2.withObject(object!);
    _methodsObject[methodName] = m2;
    return m2;
  }

  MethodReflection<TestDomainWithReflection, dynamic>? _methodImpl(
      String methodName, TestDomainWithReflection? obj) {
    obj ??= object;

    var lc = methodName.trim().toLowerCase();

    switch (lc) {
      case 'typedfunction':
        return MethodReflection<TestDomainWithReflection, bool>(
            this,
            TestDomainWithReflection,
            'typedFunction',
            __TR.tBool,
            false,
            (o) => o!.typedFunction,
            obj,
            const <__PR>[
              __PR(
                  __TR<TypedFunction<dynamic>>(
                      TypedFunction, <__TR>[__TR.tDynamic]),
                  'f',
                  false,
                  true),
              __PR(__TR.tDynamic, 'x', false, true)
            ],
            null,
            null,
            null);
      case 'tojson':
        return MethodReflection<TestDomainWithReflection, String>(
            this,
            TestDomainWithReflection,
            'toJson',
            __TR.tString,
            false,
            (o) => o!.toJson,
            obj,
            null,
            null,
            null,
            null);
      case 'tostring':
        return MethodReflection<TestDomainWithReflection, String>(
            this,
            TestDomainWithReflection,
            'toString',
            __TR.tString,
            false,
            (o) => o!.toString,
            obj,
            null,
            null,
            null,
            const [override]);
      default:
        return null;
    }
  }

  static const List<String> _staticMethodsNames = const <String>[];

  @override
  List<String> get staticMethodsNames => _staticMethodsNames;

  @override
  StaticMethodReflection<TestDomainWithReflection, R>? staticMethod<R>(
          String methodName) =>
      null;
}

class TestEmpty$reflection extends ClassReflection<TestEmpty>
    with __ReflectionMixin {
  static final Expando<TestEmpty$reflection> _objectReflections = Expando();

  factory TestEmpty$reflection([TestEmpty? object]) {
    if (object == null) return staticInstance;
    return _objectReflections[object] ??= TestEmpty$reflection._(object);
  }

  TestEmpty$reflection._([TestEmpty? object])
      : super(TestEmpty, r'TestEmpty', object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestEmpty$reflection withObject([TestEmpty? obj]) =>
      TestEmpty$reflection(obj)..setupInternalsWith(this);

  static TestEmpty$reflection? _withoutObjectInstance;
  @override
  TestEmpty$reflection withoutObjectInstance() => staticInstance;

  static TestEmpty$reflection get staticInstance =>
      _withoutObjectInstance ??= TestEmpty$reflection._();

  @override
  TestEmpty$reflection getStaticInstance() => staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestEmpty$reflection.staticInstance;
  }

  @override
  bool get hasDefaultConstructor => true;
  @override
  TestEmpty? createInstanceWithDefaultConstructor() => TestEmpty();

  @override
  bool get hasEmptyConstructor => false;
  @override
  TestEmpty? createInstanceWithEmptyConstructor() => null;
  @override
  bool get hasNoRequiredArgsConstructor => false;
  @override
  TestEmpty? createInstanceWithNoRequiredArgsConstructor() => null;

  static const List<String> _constructorsNames = const <String>[''];

  @override
  List<String> get constructorsNames => _constructorsNames;

  static final Map<String, ConstructorReflection<TestEmpty>> _constructors = {};

  @override
  ConstructorReflection<TestEmpty>? constructor(String constructorName) {
    var c = _constructors[constructorName];
    if (c != null) return c;
    c = _constructorImpl(constructorName);
    if (c == null) return null;
    _constructors[constructorName] = c;
    return c;
  }

  ConstructorReflection<TestEmpty>? _constructorImpl(String constructorName) {
    var lc = constructorName.trim().toLowerCase();

    switch (lc) {
      case '':
        return ConstructorReflection<TestEmpty>(this, TestEmpty, '',
            () => () => TestEmpty(), null, null, null, null);
      default:
        return null;
    }
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<Type> _supperTypes = const <Type>[];

  @override
  List<Type> get supperTypes => _supperTypes;

  @override
  bool get hasMethodToJson => false;

  @override
  Object? callMethodToJson([TestEmpty? obj]) => null;

  static const List<String> _fieldsNames = const <String>[];

  @override
  List<String> get fieldsNames => _fieldsNames;

  @override
  FieldReflection<TestEmpty, T>? field<T>(String fieldName, [TestEmpty? obj]) =>
      null;

  @override
  Map<String, dynamic> getFieldsValues(TestEmpty? obj,
          {bool withHashCode = false}) =>
      {
        if (withHashCode) 'hashCode': obj?.hashCode,
      };

  static const List<String> _staticFieldsNames = const <String>[];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  @override
  StaticFieldReflection<TestEmpty, T>? staticField<T>(String fieldName) => null;

  static const List<String> _methodsNames = const <String>[];

  @override
  List<String> get methodsNames => _methodsNames;

  @override
  MethodReflection<TestEmpty, R>? method<R>(String methodName,
          [TestEmpty? obj]) =>
      null;
  static const List<String> _staticMethodsNames = const <String>[];

  @override
  List<String> get staticMethodsNames => _staticMethodsNames;

  @override
  StaticMethodReflection<TestEmpty, R>? staticMethod<R>(String methodName) =>
      null;
}

class TestEnumWithReflection$reflection
    extends EnumReflection<TestEnumWithReflection> with __ReflectionMixin {
  static final Expando<TestEnumWithReflection$reflection> _objectReflections =
      Expando();

  factory TestEnumWithReflection$reflection([TestEnumWithReflection? object]) {
    if (object == null) return staticInstance;
    return _objectReflections[object] ??=
        TestEnumWithReflection$reflection._(object);
  }

  TestEnumWithReflection$reflection._([TestEnumWithReflection? object])
      : super(TestEnumWithReflection, r'TestEnumWithReflection', object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestEnumWithReflection$reflection withObject([TestEnumWithReflection? obj]) =>
      TestEnumWithReflection$reflection(obj);

  static TestEnumWithReflection$reflection? _withoutObjectInstance;
  @override
  TestEnumWithReflection$reflection withoutObjectInstance() => staticInstance;

  static TestEnumWithReflection$reflection get staticInstance =>
      _withoutObjectInstance ??= TestEnumWithReflection$reflection._();

  @override
  TestEnumWithReflection$reflection getStaticInstance() => staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestEnumWithReflection$reflection.staticInstance;
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<String> _staticFieldsNames = const <String>[
    'Z',
    'length',
    'x',
    'y',
    'z'
  ];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  static const Map<String, TestEnumWithReflection> _valuesByName =
      const <String, TestEnumWithReflection>{
    'Z': TestEnumWithReflection.Z,
    'x': TestEnumWithReflection.x,
    'y': TestEnumWithReflection.y,
    'z': TestEnumWithReflection.z,
  };

  @override
  Map<String, TestEnumWithReflection> get valuesByName => _valuesByName;
  @override
  List<TestEnumWithReflection> get values => TestEnumWithReflection.values;

  static const List<String> _fieldsNames = const <String>['nameLC'];

  @override
  List<String> get fieldsNames => _fieldsNames;
}

class TestFranchiseWithReflection$reflection
    extends ClassReflection<TestFranchiseWithReflection>
    with __ReflectionMixin {
  static final Expando<TestFranchiseWithReflection$reflection>
      _objectReflections = Expando();

  factory TestFranchiseWithReflection$reflection(
      [TestFranchiseWithReflection? object]) {
    if (object == null) return staticInstance;
    return _objectReflections[object] ??=
        TestFranchiseWithReflection$reflection._(object);
  }

  TestFranchiseWithReflection$reflection._(
      [TestFranchiseWithReflection? object])
      : super(TestFranchiseWithReflection, r'TestFranchiseWithReflection',
            object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestFranchiseWithReflection$reflection withObject(
          [TestFranchiseWithReflection? obj]) =>
      TestFranchiseWithReflection$reflection(obj)..setupInternalsWith(this);

  static TestFranchiseWithReflection$reflection? _withoutObjectInstance;
  @override
  TestFranchiseWithReflection$reflection withoutObjectInstance() =>
      staticInstance;

  static TestFranchiseWithReflection$reflection get staticInstance =>
      _withoutObjectInstance ??= TestFranchiseWithReflection$reflection._();

  @override
  TestFranchiseWithReflection$reflection getStaticInstance() => staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestFranchiseWithReflection$reflection.staticInstance;
  }

  @override
  bool get hasDefaultConstructor => false;
  @override
  TestFranchiseWithReflection? createInstanceWithDefaultConstructor() => null;

  @override
  bool get hasEmptyConstructor => false;
  @override
  TestFranchiseWithReflection? createInstanceWithEmptyConstructor() => null;
  @override
  bool get hasNoRequiredArgsConstructor => false;
  @override
  TestFranchiseWithReflection? createInstanceWithNoRequiredArgsConstructor() =>
      null;

  static const List<String> _constructorsNames = const <String>[''];

  @override
  List<String> get constructorsNames => _constructorsNames;

  static final Map<String, ConstructorReflection<TestFranchiseWithReflection>>
      _constructors = {};

  @override
  ConstructorReflection<TestFranchiseWithReflection>? constructor(
      String constructorName) {
    var c = _constructors[constructorName];
    if (c != null) return c;
    c = _constructorImpl(constructorName);
    if (c == null) return null;
    _constructors[constructorName] = c;
    return c;
  }

  ConstructorReflection<TestFranchiseWithReflection>? _constructorImpl(
      String constructorName) {
    var lc = constructorName.trim().toLowerCase();

    switch (lc) {
      case '':
        return ConstructorReflection<TestFranchiseWithReflection>(
            this,
            TestFranchiseWithReflection,
            '',
            () => (String name,
                    Map<String, TestAddressWithReflection> addresses) =>
                TestFranchiseWithReflection(name, addresses),
            const <__PR>[
              __PR(__TR.tString, 'name', false, true),
              __PR(
                  __TR<Map<String, TestAddressWithReflection>>(Map, <__TR>[
                    __TR.tString,
                    __TR<TestAddressWithReflection>(TestAddressWithReflection)
                  ]),
                  'addresses',
                  false,
                  true)
            ],
            null,
            null,
            null);
      default:
        return null;
    }
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<Type> _supperTypes = const <Type>[];

  @override
  List<Type> get supperTypes => _supperTypes;

  @override
  bool get hasMethodToJson => false;

  @override
  Object? callMethodToJson([TestFranchiseWithReflection? obj]) => null;

  static const List<String> _fieldsNames = const <String>[
    'addresses',
    'hashCode',
    'name'
  ];

  @override
  List<String> get fieldsNames => _fieldsNames;

  static final Map<String,
          FieldReflection<TestFranchiseWithReflection, dynamic>>
      _fieldsNoObject = {};

  final Map<String, FieldReflection<TestFranchiseWithReflection, dynamic>>
      _fieldsObject = {};

  @override
  FieldReflection<TestFranchiseWithReflection, T>? field<T>(String fieldName,
      [TestFranchiseWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _fieldObjectImpl<T>(fieldName);
      } else {
        return _fieldNoObjectImpl<T>(fieldName);
      }
    } else if (identical(obj, object)) {
      return _fieldObjectImpl<T>(fieldName);
    }
    return _fieldNoObjectImpl<T>(fieldName)?.withObject(obj);
  }

  FieldReflection<TestFranchiseWithReflection, T>? _fieldNoObjectImpl<T>(
      String fieldName) {
    final f = _fieldsNoObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestFranchiseWithReflection, T>;
    }
    final f2 = _fieldImpl(fieldName, null);
    if (f2 == null) return null;
    _fieldsNoObject[fieldName] = f2;
    return f2 as FieldReflection<TestFranchiseWithReflection, T>;
  }

  FieldReflection<TestFranchiseWithReflection, T>? _fieldObjectImpl<T>(
      String fieldName) {
    final f = _fieldsObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestFranchiseWithReflection, T>;
    }
    var f2 = _fieldNoObjectImpl<T>(fieldName);
    if (f2 == null) return null;
    f2 = f2.withObject(object!);
    _fieldsObject[fieldName] = f2;
    return f2;
  }

  FieldReflection<TestFranchiseWithReflection, dynamic>? _fieldImpl(
      String fieldName, TestFranchiseWithReflection? obj) {
    obj ??= object;

    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'name':
        return FieldReflection<TestFranchiseWithReflection, String>(
          this,
          TestFranchiseWithReflection,
          __TR.tString,
          'name',
          false,
          (o) => () => o!.name,
          null,
          obj,
          true,
        );
      case 'addresses':
        return FieldReflection<TestFranchiseWithReflection,
            Map<String, TestAddressWithReflection>>(
          this,
          TestFranchiseWithReflection,
          __TR<Map<String, TestAddressWithReflection>>(Map, <__TR>[
            __TR.tString,
            __TR<TestAddressWithReflection>(TestAddressWithReflection)
          ]),
          'addresses',
          false,
          (o) => () => o!.addresses,
          (o) => (v) => o!.addresses = v,
          obj,
          false,
        );
      case 'hashcode':
        return FieldReflection<TestFranchiseWithReflection, int>(
          this,
          TestFranchiseWithReflection,
          __TR.tInt,
          'hashCode',
          false,
          (o) => () => o!.hashCode,
          null,
          obj,
          false,
          const [override],
        );
      default:
        return null;
    }
  }

  @override
  Map<String, dynamic> getFieldsValues(TestFranchiseWithReflection? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'name': obj?.name,
      'addresses': obj?.addresses,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  static const List<String> _staticFieldsNames = const <String>[];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  @override
  StaticFieldReflection<TestFranchiseWithReflection, T>? staticField<T>(
          String fieldName) =>
      null;

  static const List<String> _methodsNames = const <String>['toString'];

  @override
  List<String> get methodsNames => _methodsNames;

  static final Map<String,
          MethodReflection<TestFranchiseWithReflection, dynamic>>
      _methodsNoObject = {};

  final Map<String, MethodReflection<TestFranchiseWithReflection, dynamic>>
      _methodsObject = {};

  @override
  MethodReflection<TestFranchiseWithReflection, R>? method<R>(String methodName,
      [TestFranchiseWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _methodObjectImpl<R>(methodName);
      } else {
        return _methodNoObjectImpl<R>(methodName);
      }
    } else if (identical(obj, object)) {
      return _methodObjectImpl<R>(methodName);
    }
    return _methodNoObjectImpl<R>(methodName)?.withObject(obj);
  }

  MethodReflection<TestFranchiseWithReflection, R>? _methodNoObjectImpl<R>(
      String methodName) {
    final m = _methodsNoObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestFranchiseWithReflection, R>;
    }
    final m2 = _methodImpl(methodName, null);
    if (m2 == null) return null;
    _methodsNoObject[methodName] = m2;
    return m2 as MethodReflection<TestFranchiseWithReflection, R>;
  }

  MethodReflection<TestFranchiseWithReflection, R>? _methodObjectImpl<R>(
      String methodName) {
    final m = _methodsObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestFranchiseWithReflection, R>;
    }
    var m2 = _methodNoObjectImpl<R>(methodName);
    if (m2 == null) return null;
    m2 = m2.withObject(object!);
    _methodsObject[methodName] = m2;
    return m2;
  }

  MethodReflection<TestFranchiseWithReflection, dynamic>? _methodImpl(
      String methodName, TestFranchiseWithReflection? obj) {
    obj ??= object;

    var lc = methodName.trim().toLowerCase();

    switch (lc) {
      case 'tostring':
        return MethodReflection<TestFranchiseWithReflection, String>(
            this,
            TestFranchiseWithReflection,
            'toString',
            __TR.tString,
            false,
            (o) => o!.toString,
            obj,
            null,
            null,
            null,
            const [override]);
      default:
        return null;
    }
  }

  static const List<String> _staticMethodsNames = const <String>[];

  @override
  List<String> get staticMethodsNames => _staticMethodsNames;

  @override
  StaticMethodReflection<TestFranchiseWithReflection, R>? staticMethod<R>(
          String methodName) =>
      null;
}

class TestName$reflection extends ClassReflection<TestName>
    with __ReflectionMixin {
  static final Expando<TestName$reflection> _objectReflections = Expando();

  factory TestName$reflection([TestName? object]) {
    if (object == null) return staticInstance;
    return _objectReflections[object] ??= TestName$reflection._(object);
  }

  TestName$reflection._([TestName? object])
      : super(TestName, r'TestName', object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestName$reflection withObject([TestName? obj]) =>
      TestName$reflection(obj)..setupInternalsWith(this);

  static TestName$reflection? _withoutObjectInstance;
  @override
  TestName$reflection withoutObjectInstance() => staticInstance;

  static TestName$reflection get staticInstance =>
      _withoutObjectInstance ??= TestName$reflection._();

  @override
  TestName$reflection getStaticInstance() => staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestName$reflection.staticInstance;
  }

  @override
  bool get hasDefaultConstructor => true;
  @override
  TestName? createInstanceWithDefaultConstructor() => TestName();

  @override
  bool get hasEmptyConstructor => false;
  @override
  TestName? createInstanceWithEmptyConstructor() => null;
  @override
  bool get hasNoRequiredArgsConstructor => false;
  @override
  TestName? createInstanceWithNoRequiredArgsConstructor() => null;

  static const List<String> _constructorsNames = const <String>[''];

  @override
  List<String> get constructorsNames => _constructorsNames;

  static final Map<String, ConstructorReflection<TestName>> _constructors = {};

  @override
  ConstructorReflection<TestName>? constructor(String constructorName) {
    var c = _constructors[constructorName];
    if (c != null) return c;
    c = _constructorImpl(constructorName);
    if (c == null) return null;
    _constructors[constructorName] = c;
    return c;
  }

  ConstructorReflection<TestName>? _constructorImpl(String constructorName) {
    var lc = constructorName.trim().toLowerCase();

    switch (lc) {
      case '':
        return ConstructorReflection<TestName>(
            this, TestName, '', () => () => TestName(), null, null, null, null);
      default:
        return null;
    }
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<Type> _supperTypes = const <Type>[];

  @override
  List<Type> get supperTypes => _supperTypes;

  @override
  bool get hasMethodToJson => false;

  @override
  Object? callMethodToJson([TestName? obj]) => null;

  static const List<String> _fieldsNames = const <String>['isEmpty', 'name'];

  @override
  List<String> get fieldsNames => _fieldsNames;

  static final Map<String, FieldReflection<TestName, dynamic>> _fieldsNoObject =
      {};

  final Map<String, FieldReflection<TestName, dynamic>> _fieldsObject = {};

  @override
  FieldReflection<TestName, T>? field<T>(String fieldName, [TestName? obj]) {
    if (obj == null) {
      if (object != null) {
        return _fieldObjectImpl<T>(fieldName);
      } else {
        return _fieldNoObjectImpl<T>(fieldName);
      }
    } else if (identical(obj, object)) {
      return _fieldObjectImpl<T>(fieldName);
    }
    return _fieldNoObjectImpl<T>(fieldName)?.withObject(obj);
  }

  FieldReflection<TestName, T>? _fieldNoObjectImpl<T>(String fieldName) {
    final f = _fieldsNoObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestName, T>;
    }
    final f2 = _fieldImpl(fieldName, null);
    if (f2 == null) return null;
    _fieldsNoObject[fieldName] = f2;
    return f2 as FieldReflection<TestName, T>;
  }

  FieldReflection<TestName, T>? _fieldObjectImpl<T>(String fieldName) {
    final f = _fieldsObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestName, T>;
    }
    var f2 = _fieldNoObjectImpl<T>(fieldName);
    if (f2 == null) return null;
    f2 = f2.withObject(object!);
    _fieldsObject[fieldName] = f2;
    return f2;
  }

  FieldReflection<TestName, dynamic>? _fieldImpl(
      String fieldName, TestName? obj) {
    obj ??= object;

    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'name':
        return FieldReflection<TestName, String?>(
          this,
          TestName,
          __TR.tString,
          'name',
          true,
          (o) => () => o!.name,
          (o) => (v) => o!.name = v,
          obj,
          false,
        );
      case 'isempty':
        return FieldReflection<TestName, bool>(
          this,
          TestName,
          __TR.tBool,
          'isEmpty',
          false,
          (o) => () => o!.isEmpty,
          null,
          obj,
          false,
        );
      default:
        return null;
    }
  }

  @override
  Map<String, dynamic> getFieldsValues(TestName? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'name': obj?.name,
      'isEmpty': obj?.isEmpty,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  static const List<String> _staticFieldsNames = const <String>[];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  @override
  StaticFieldReflection<TestName, T>? staticField<T>(String fieldName) => null;

  static const List<String> _methodsNames = const <String>[
    'nameNormalized',
    'toString'
  ];

  @override
  List<String> get methodsNames => _methodsNames;

  static final Map<String, MethodReflection<TestName, dynamic>>
      _methodsNoObject = {};

  final Map<String, MethodReflection<TestName, dynamic>> _methodsObject = {};

  @override
  MethodReflection<TestName, R>? method<R>(String methodName, [TestName? obj]) {
    if (obj == null) {
      if (object != null) {
        return _methodObjectImpl<R>(methodName);
      } else {
        return _methodNoObjectImpl<R>(methodName);
      }
    } else if (identical(obj, object)) {
      return _methodObjectImpl<R>(methodName);
    }
    return _methodNoObjectImpl<R>(methodName)?.withObject(obj);
  }

  MethodReflection<TestName, R>? _methodNoObjectImpl<R>(String methodName) {
    final m = _methodsNoObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestName, R>;
    }
    final m2 = _methodImpl(methodName, null);
    if (m2 == null) return null;
    _methodsNoObject[methodName] = m2;
    return m2 as MethodReflection<TestName, R>;
  }

  MethodReflection<TestName, R>? _methodObjectImpl<R>(String methodName) {
    final m = _methodsObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestName, R>;
    }
    var m2 = _methodNoObjectImpl<R>(methodName);
    if (m2 == null) return null;
    m2 = m2.withObject(object!);
    _methodsObject[methodName] = m2;
    return m2;
  }

  MethodReflection<TestName, dynamic>? _methodImpl(
      String methodName, TestName? obj) {
    obj ??= object;

    var lc = methodName.trim().toLowerCase();

    switch (lc) {
      case 'namenormalized':
        return MethodReflection<TestName, String>(
            this,
            TestName,
            'nameNormalized',
            __TR.tString,
            false,
            (o) => o!.nameNormalized,
            obj,
            null,
            null,
            null,
            null);
      case 'tostring':
        return MethodReflection<TestName, String>(
            this,
            TestName,
            'toString',
            __TR.tString,
            false,
            (o) => o!.toString,
            obj,
            null,
            null,
            null,
            const [override]);
      default:
        return null;
    }
  }

  static const List<String> _staticMethodsNames = const <String>[];

  @override
  List<String> get staticMethodsNames => _staticMethodsNames;

  @override
  StaticMethodReflection<TestName, R>? staticMethod<R>(String methodName) =>
      null;
}

class TestOpAWithReflection$reflection
    extends ClassReflection<TestOpAWithReflection> with __ReflectionMixin {
  static final Expando<TestOpAWithReflection$reflection> _objectReflections =
      Expando();

  factory TestOpAWithReflection$reflection([TestOpAWithReflection? object]) {
    if (object == null) return staticInstance;
    return _objectReflections[object] ??=
        TestOpAWithReflection$reflection._(object);
  }

  TestOpAWithReflection$reflection._([TestOpAWithReflection? object])
      : super(TestOpAWithReflection, r'TestOpAWithReflection', object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestOpAWithReflection$reflection withObject([TestOpAWithReflection? obj]) =>
      TestOpAWithReflection$reflection(obj)..setupInternalsWith(this);

  static TestOpAWithReflection$reflection? _withoutObjectInstance;
  @override
  TestOpAWithReflection$reflection withoutObjectInstance() => staticInstance;

  static TestOpAWithReflection$reflection get staticInstance =>
      _withoutObjectInstance ??= TestOpAWithReflection$reflection._();

  @override
  TestOpAWithReflection$reflection getStaticInstance() => staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestOpAWithReflection$reflection.staticInstance;
  }

  @override
  bool get hasDefaultConstructor => false;
  @override
  TestOpAWithReflection? createInstanceWithDefaultConstructor() => null;

  @override
  bool get hasEmptyConstructor => false;
  @override
  TestOpAWithReflection? createInstanceWithEmptyConstructor() => null;
  @override
  bool get hasNoRequiredArgsConstructor => false;
  @override
  TestOpAWithReflection? createInstanceWithNoRequiredArgsConstructor() => null;

  static const List<String> _constructorsNames = const <String>[''];

  @override
  List<String> get constructorsNames => _constructorsNames;

  static final Map<String, ConstructorReflection<TestOpAWithReflection>>
      _constructors = {};

  @override
  ConstructorReflection<TestOpAWithReflection>? constructor(
      String constructorName) {
    var c = _constructors[constructorName];
    if (c != null) return c;
    c = _constructorImpl(constructorName);
    if (c == null) return null;
    _constructors[constructorName] = c;
    return c;
  }

  ConstructorReflection<TestOpAWithReflection>? _constructorImpl(
      String constructorName) {
    var lc = constructorName.trim().toLowerCase();

    switch (lc) {
      case '':
        return ConstructorReflection<TestOpAWithReflection>(
            this,
            TestOpAWithReflection,
            '',
            () => (int value) => TestOpAWithReflection(value),
            const <__PR>[__PR(__TR.tInt, 'value', false, true)],
            null,
            null,
            null);
      default:
        return null;
    }
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<Type> _supperTypes = const <Type>[
    TestOpWithReflection,
    WithValue
  ];

  @override
  List<Type> get supperTypes => _supperTypes;

  @override
  bool get hasMethodToJson => false;

  @override
  Object? callMethodToJson([TestOpAWithReflection? obj]) => null;

  static const List<String> _fieldsNames = const <String>['type', 'value'];

  @override
  List<String> get fieldsNames => _fieldsNames;

  static final Map<String, FieldReflection<TestOpAWithReflection, dynamic>>
      _fieldsNoObject = {};

  final Map<String, FieldReflection<TestOpAWithReflection, dynamic>>
      _fieldsObject = {};

  @override
  FieldReflection<TestOpAWithReflection, T>? field<T>(String fieldName,
      [TestOpAWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _fieldObjectImpl<T>(fieldName);
      } else {
        return _fieldNoObjectImpl<T>(fieldName);
      }
    } else if (identical(obj, object)) {
      return _fieldObjectImpl<T>(fieldName);
    }
    return _fieldNoObjectImpl<T>(fieldName)?.withObject(obj);
  }

  FieldReflection<TestOpAWithReflection, T>? _fieldNoObjectImpl<T>(
      String fieldName) {
    final f = _fieldsNoObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestOpAWithReflection, T>;
    }
    final f2 = _fieldImpl(fieldName, null);
    if (f2 == null) return null;
    _fieldsNoObject[fieldName] = f2;
    return f2 as FieldReflection<TestOpAWithReflection, T>;
  }

  FieldReflection<TestOpAWithReflection, T>? _fieldObjectImpl<T>(
      String fieldName) {
    final f = _fieldsObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestOpAWithReflection, T>;
    }
    var f2 = _fieldNoObjectImpl<T>(fieldName);
    if (f2 == null) return null;
    f2 = f2.withObject(object!);
    _fieldsObject[fieldName] = f2;
    return f2;
  }

  FieldReflection<TestOpAWithReflection, dynamic>? _fieldImpl(
      String fieldName, TestOpAWithReflection? obj) {
    obj ??= object;

    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'value':
        return FieldReflection<TestOpAWithReflection, int>(
          this,
          TestOpAWithReflection,
          __TR.tInt,
          'value',
          false,
          (o) => () => o!.value,
          (o) => (v) => o!.value = v,
          obj,
          false,
          const [override, override],
        );
      case 'type':
        return FieldReflection<TestOpAWithReflection, String>(
          this,
          TestOpWithReflection,
          __TR.tString,
          'type',
          false,
          (o) => () => o!.type,
          null,
          obj,
          true,
        );
      default:
        return null;
    }
  }

  @override
  Map<String, dynamic> getFieldsValues(TestOpAWithReflection? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'value': obj?.value,
      'type': obj?.type,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  static const List<String> _staticFieldsNames = const <String>['staticFieldA'];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  static final Map<String,
      StaticFieldReflection<TestOpAWithReflection, dynamic>> _staticFields = {};

  @override
  StaticFieldReflection<TestOpAWithReflection, T>? staticField<T>(
      String fieldName) {
    var f = _staticFields[fieldName];
    if (f != null) {
      return f as StaticFieldReflection<TestOpAWithReflection, T>;
    }
    f = _staticFieldImpl(fieldName);
    if (f == null) return null;
    _staticFields[fieldName] = f;
    return f as StaticFieldReflection<TestOpAWithReflection, T>;
  }

  StaticFieldReflection<TestOpAWithReflection, dynamic>? _staticFieldImpl(
      String fieldName) {
    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'staticfielda':
        return StaticFieldReflection<TestOpAWithReflection, int>(
          this,
          TestOpAWithReflection,
          __TR.tInt,
          'staticFieldA',
          false,
          () => () => TestOpAWithReflection.staticFieldA,
          () => (v) => TestOpAWithReflection.staticFieldA = v,
          false,
          null,
        );
      default:
        return null;
    }
  }

  static const List<String> _methodsNames = const <String>[
    'isEmptyType',
    'methodA'
  ];

  @override
  List<String> get methodsNames => _methodsNames;

  static final Map<String, MethodReflection<TestOpAWithReflection, dynamic>>
      _methodsNoObject = {};

  final Map<String, MethodReflection<TestOpAWithReflection, dynamic>>
      _methodsObject = {};

  @override
  MethodReflection<TestOpAWithReflection, R>? method<R>(String methodName,
      [TestOpAWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _methodObjectImpl<R>(methodName);
      } else {
        return _methodNoObjectImpl<R>(methodName);
      }
    } else if (identical(obj, object)) {
      return _methodObjectImpl<R>(methodName);
    }
    return _methodNoObjectImpl<R>(methodName)?.withObject(obj);
  }

  MethodReflection<TestOpAWithReflection, R>? _methodNoObjectImpl<R>(
      String methodName) {
    final m = _methodsNoObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestOpAWithReflection, R>;
    }
    final m2 = _methodImpl(methodName, null);
    if (m2 == null) return null;
    _methodsNoObject[methodName] = m2;
    return m2 as MethodReflection<TestOpAWithReflection, R>;
  }

  MethodReflection<TestOpAWithReflection, R>? _methodObjectImpl<R>(
      String methodName) {
    final m = _methodsObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestOpAWithReflection, R>;
    }
    var m2 = _methodNoObjectImpl<R>(methodName);
    if (m2 == null) return null;
    m2 = m2.withObject(object!);
    _methodsObject[methodName] = m2;
    return m2;
  }

  MethodReflection<TestOpAWithReflection, dynamic>? _methodImpl(
      String methodName, TestOpAWithReflection? obj) {
    obj ??= object;

    var lc = methodName.trim().toLowerCase();

    switch (lc) {
      case 'methoda':
        return MethodReflection<TestOpAWithReflection, bool>(
            this,
            TestOpAWithReflection,
            'methodA',
            __TR.tBool,
            false,
            (o) => o!.methodA,
            obj,
            null,
            null,
            null,
            null);
      case 'isemptytype':
        return MethodReflection<TestOpAWithReflection, bool>(
            this,
            TestOpWithReflection,
            'isEmptyType',
            __TR.tBool,
            false,
            (o) => o!.isEmptyType,
            obj,
            null,
            null,
            null,
            null);
      default:
        return null;
    }
  }

  static const List<String> _staticMethodsNames = const <String>[];

  @override
  List<String> get staticMethodsNames => _staticMethodsNames;

  @override
  StaticMethodReflection<TestOpAWithReflection, R>? staticMethod<R>(
          String methodName) =>
      null;
}

class TestOpBWithReflection$reflection
    extends ClassReflection<TestOpBWithReflection> with __ReflectionMixin {
  static final Expando<TestOpBWithReflection$reflection> _objectReflections =
      Expando();

  factory TestOpBWithReflection$reflection([TestOpBWithReflection? object]) {
    if (object == null) return staticInstance;
    return _objectReflections[object] ??=
        TestOpBWithReflection$reflection._(object);
  }

  TestOpBWithReflection$reflection._([TestOpBWithReflection? object])
      : super(TestOpBWithReflection, r'TestOpBWithReflection', object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestOpBWithReflection$reflection withObject([TestOpBWithReflection? obj]) =>
      TestOpBWithReflection$reflection(obj)..setupInternalsWith(this);

  static TestOpBWithReflection$reflection? _withoutObjectInstance;
  @override
  TestOpBWithReflection$reflection withoutObjectInstance() => staticInstance;

  static TestOpBWithReflection$reflection get staticInstance =>
      _withoutObjectInstance ??= TestOpBWithReflection$reflection._();

  @override
  TestOpBWithReflection$reflection getStaticInstance() => staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestOpBWithReflection$reflection.staticInstance;
  }

  @override
  bool get hasDefaultConstructor => false;
  @override
  TestOpBWithReflection? createInstanceWithDefaultConstructor() => null;

  @override
  bool get hasEmptyConstructor => false;
  @override
  TestOpBWithReflection? createInstanceWithEmptyConstructor() => null;
  @override
  bool get hasNoRequiredArgsConstructor => false;
  @override
  TestOpBWithReflection? createInstanceWithNoRequiredArgsConstructor() => null;

  static const List<String> _constructorsNames = const <String>[''];

  @override
  List<String> get constructorsNames => _constructorsNames;

  static final Map<String, ConstructorReflection<TestOpBWithReflection>>
      _constructors = {};

  @override
  ConstructorReflection<TestOpBWithReflection>? constructor(
      String constructorName) {
    var c = _constructors[constructorName];
    if (c != null) return c;
    c = _constructorImpl(constructorName);
    if (c == null) return null;
    _constructors[constructorName] = c;
    return c;
  }

  ConstructorReflection<TestOpBWithReflection>? _constructorImpl(
      String constructorName) {
    var lc = constructorName.trim().toLowerCase();

    switch (lc) {
      case '':
        return ConstructorReflection<TestOpBWithReflection>(
            this,
            TestOpBWithReflection,
            '',
            () => (double amount) => TestOpBWithReflection(amount),
            const <__PR>[__PR(__TR.tDouble, 'amount', false, true)],
            null,
            null,
            null);
      default:
        return null;
    }
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<Type> _supperTypes = const <Type>[
    TestOpWithReflection,
    WithValue
  ];

  @override
  List<Type> get supperTypes => _supperTypes;

  @override
  bool get hasMethodToJson => false;

  @override
  Object? callMethodToJson([TestOpBWithReflection? obj]) => null;

  static const List<String> _fieldsNames = const <String>[
    'amount',
    'type',
    'value'
  ];

  @override
  List<String> get fieldsNames => _fieldsNames;

  static final Map<String, FieldReflection<TestOpBWithReflection, dynamic>>
      _fieldsNoObject = {};

  final Map<String, FieldReflection<TestOpBWithReflection, dynamic>>
      _fieldsObject = {};

  @override
  FieldReflection<TestOpBWithReflection, T>? field<T>(String fieldName,
      [TestOpBWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _fieldObjectImpl<T>(fieldName);
      } else {
        return _fieldNoObjectImpl<T>(fieldName);
      }
    } else if (identical(obj, object)) {
      return _fieldObjectImpl<T>(fieldName);
    }
    return _fieldNoObjectImpl<T>(fieldName)?.withObject(obj);
  }

  FieldReflection<TestOpBWithReflection, T>? _fieldNoObjectImpl<T>(
      String fieldName) {
    final f = _fieldsNoObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestOpBWithReflection, T>;
    }
    final f2 = _fieldImpl(fieldName, null);
    if (f2 == null) return null;
    _fieldsNoObject[fieldName] = f2;
    return f2 as FieldReflection<TestOpBWithReflection, T>;
  }

  FieldReflection<TestOpBWithReflection, T>? _fieldObjectImpl<T>(
      String fieldName) {
    final f = _fieldsObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestOpBWithReflection, T>;
    }
    var f2 = _fieldNoObjectImpl<T>(fieldName);
    if (f2 == null) return null;
    f2 = f2.withObject(object!);
    _fieldsObject[fieldName] = f2;
    return f2;
  }

  FieldReflection<TestOpBWithReflection, dynamic>? _fieldImpl(
      String fieldName, TestOpBWithReflection? obj) {
    obj ??= object;

    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'amount':
        return FieldReflection<TestOpBWithReflection, double>(
          this,
          TestOpBWithReflection,
          __TR.tDouble,
          'amount',
          false,
          (o) => () => o!.amount,
          (o) => (v) => o!.amount = v,
          obj,
          false,
        );
      case 'type':
        return FieldReflection<TestOpBWithReflection, String>(
          this,
          TestOpWithReflection,
          __TR.tString,
          'type',
          false,
          (o) => () => o!.type,
          null,
          obj,
          true,
        );
      case 'value':
        return FieldReflection<TestOpBWithReflection, dynamic>(
          this,
          WithValue,
          __TR.tDynamic,
          'value',
          true,
          (o) => () => o!.value,
          (o) => (v) => o!.value = v,
          obj,
          false,
        );
      default:
        return null;
    }
  }

  @override
  Map<String, dynamic> getFieldsValues(TestOpBWithReflection? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'amount': obj?.amount,
      'type': obj?.type,
      'value': obj?.value,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  static const List<String> _staticFieldsNames = const <String>[];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  @override
  StaticFieldReflection<TestOpBWithReflection, T>? staticField<T>(
          String fieldName) =>
      null;

  static const List<String> _methodsNames = const <String>[
    'isEmptyType',
    'methodB'
  ];

  @override
  List<String> get methodsNames => _methodsNames;

  static final Map<String, MethodReflection<TestOpBWithReflection, dynamic>>
      _methodsNoObject = {};

  final Map<String, MethodReflection<TestOpBWithReflection, dynamic>>
      _methodsObject = {};

  @override
  MethodReflection<TestOpBWithReflection, R>? method<R>(String methodName,
      [TestOpBWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _methodObjectImpl<R>(methodName);
      } else {
        return _methodNoObjectImpl<R>(methodName);
      }
    } else if (identical(obj, object)) {
      return _methodObjectImpl<R>(methodName);
    }
    return _methodNoObjectImpl<R>(methodName)?.withObject(obj);
  }

  MethodReflection<TestOpBWithReflection, R>? _methodNoObjectImpl<R>(
      String methodName) {
    final m = _methodsNoObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestOpBWithReflection, R>;
    }
    final m2 = _methodImpl(methodName, null);
    if (m2 == null) return null;
    _methodsNoObject[methodName] = m2;
    return m2 as MethodReflection<TestOpBWithReflection, R>;
  }

  MethodReflection<TestOpBWithReflection, R>? _methodObjectImpl<R>(
      String methodName) {
    final m = _methodsObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestOpBWithReflection, R>;
    }
    var m2 = _methodNoObjectImpl<R>(methodName);
    if (m2 == null) return null;
    m2 = m2.withObject(object!);
    _methodsObject[methodName] = m2;
    return m2;
  }

  MethodReflection<TestOpBWithReflection, dynamic>? _methodImpl(
      String methodName, TestOpBWithReflection? obj) {
    obj ??= object;

    var lc = methodName.trim().toLowerCase();

    switch (lc) {
      case 'methodb':
        return MethodReflection<TestOpBWithReflection, Set<dynamic>>(
            this,
            TestOpBWithReflection,
            'methodB',
            __TR.tSetDynamic,
            false,
            (o) => o!.methodB,
            obj,
            null,
            null,
            null,
            null);
      case 'isemptytype':
        return MethodReflection<TestOpBWithReflection, bool>(
            this,
            TestOpWithReflection,
            'isEmptyType',
            __TR.tBool,
            false,
            (o) => o!.isEmptyType,
            obj,
            null,
            null,
            null,
            null);
      default:
        return null;
    }
  }

  static const List<String> _staticMethodsNames = const <String>[
    'staticMethodB'
  ];

  @override
  List<String> get staticMethodsNames => _staticMethodsNames;

  static final Map<String,
          StaticMethodReflection<TestOpBWithReflection, dynamic>>
      _staticMethods = {};

  @override
  StaticMethodReflection<TestOpBWithReflection, R>? staticMethod<R>(
      String methodName) {
    var m = _staticMethods[methodName];
    if (m != null) {
      return m as StaticMethodReflection<TestOpBWithReflection, R>;
    }
    m = _staticMethodImpl(methodName);
    if (m == null) return null;
    _staticMethods[methodName] = m;
    return m as StaticMethodReflection<TestOpBWithReflection, R>;
  }

  StaticMethodReflection<TestOpBWithReflection, dynamic>? _staticMethodImpl(
      String methodName) {
    var lc = methodName.trim().toLowerCase();

    switch (lc) {
      case 'staticmethodb':
        return StaticMethodReflection<TestOpBWithReflection, bool>(
            this,
            TestOpBWithReflection,
            'staticMethodB',
            __TR.tBool,
            false,
            () => TestOpBWithReflection.staticMethodB,
            null,
            null,
            null,
            null);
      default:
        return null;
    }
  }
}

class TestOpWithReflection$reflection
    extends ClassReflection<TestOpWithReflection> with __ReflectionMixin {
  static final Expando<TestOpWithReflection$reflection> _objectReflections =
      Expando();

  factory TestOpWithReflection$reflection([TestOpWithReflection? object]) {
    if (object == null) return staticInstance;
    return _objectReflections[object] ??=
        TestOpWithReflection$reflection._(object);
  }

  TestOpWithReflection$reflection._([TestOpWithReflection? object])
      : super(TestOpWithReflection, r'TestOpWithReflection', object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestOpWithReflection$reflection withObject([TestOpWithReflection? obj]) =>
      TestOpWithReflection$reflection(obj)..setupInternalsWith(this);

  static TestOpWithReflection$reflection? _withoutObjectInstance;
  @override
  TestOpWithReflection$reflection withoutObjectInstance() => staticInstance;

  static TestOpWithReflection$reflection get staticInstance =>
      _withoutObjectInstance ??= TestOpWithReflection$reflection._();

  @override
  TestOpWithReflection$reflection getStaticInstance() => staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestOpWithReflection$reflection.staticInstance;
  }

  @override
  bool get hasDefaultConstructor => false;
  @override
  TestOpWithReflection? createInstanceWithDefaultConstructor() => null;

  @override
  bool get hasEmptyConstructor => true;
  @override
  TestOpWithReflection? createInstanceWithEmptyConstructor() =>
      TestOpWithReflection.empty();
  @override
  bool get hasNoRequiredArgsConstructor => true;
  @override
  TestOpWithReflection? createInstanceWithNoRequiredArgsConstructor() =>
      TestOpWithReflection.empty();

  static const List<String> _constructorsNames = const <String>['', 'empty'];

  @override
  List<String> get constructorsNames => _constructorsNames;

  static final Map<String, ConstructorReflection<TestOpWithReflection>>
      _constructors = {};

  @override
  ConstructorReflection<TestOpWithReflection>? constructor(
      String constructorName) {
    var c = _constructors[constructorName];
    if (c != null) return c;
    c = _constructorImpl(constructorName);
    if (c == null) return null;
    _constructors[constructorName] = c;
    return c;
  }

  ConstructorReflection<TestOpWithReflection>? _constructorImpl(
      String constructorName) {
    var lc = constructorName.trim().toLowerCase();

    switch (lc) {
      case '':
        return ConstructorReflection<TestOpWithReflection>(
            this,
            TestOpWithReflection,
            '',
            () => (String type, dynamic value) =>
                TestOpWithReflection(type, value),
            const <__PR>[
              __PR(__TR.tString, 'type', false, true),
              __PR(__TR.tDynamic, 'value', true, true)
            ],
            null,
            null,
            null);
      case 'empty':
        return ConstructorReflection<TestOpWithReflection>(
            this,
            TestOpWithReflection,
            'empty',
            () => () => TestOpWithReflection.empty(),
            null,
            null,
            null,
            null);
      default:
        return null;
    }
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<Type> _supperTypes = const <Type>[WithValue];

  @override
  List<Type> get supperTypes => _supperTypes;

  @override
  bool get hasMethodToJson => false;

  @override
  Object? callMethodToJson([TestOpWithReflection? obj]) => null;

  static const List<String> _fieldsNames = const <String>['type', 'value'];

  @override
  List<String> get fieldsNames => _fieldsNames;

  static final Map<String, FieldReflection<TestOpWithReflection, dynamic>>
      _fieldsNoObject = {};

  final Map<String, FieldReflection<TestOpWithReflection, dynamic>>
      _fieldsObject = {};

  @override
  FieldReflection<TestOpWithReflection, T>? field<T>(String fieldName,
      [TestOpWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _fieldObjectImpl<T>(fieldName);
      } else {
        return _fieldNoObjectImpl<T>(fieldName);
      }
    } else if (identical(obj, object)) {
      return _fieldObjectImpl<T>(fieldName);
    }
    return _fieldNoObjectImpl<T>(fieldName)?.withObject(obj);
  }

  FieldReflection<TestOpWithReflection, T>? _fieldNoObjectImpl<T>(
      String fieldName) {
    final f = _fieldsNoObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestOpWithReflection, T>;
    }
    final f2 = _fieldImpl(fieldName, null);
    if (f2 == null) return null;
    _fieldsNoObject[fieldName] = f2;
    return f2 as FieldReflection<TestOpWithReflection, T>;
  }

  FieldReflection<TestOpWithReflection, T>? _fieldObjectImpl<T>(
      String fieldName) {
    final f = _fieldsObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestOpWithReflection, T>;
    }
    var f2 = _fieldNoObjectImpl<T>(fieldName);
    if (f2 == null) return null;
    f2 = f2.withObject(object!);
    _fieldsObject[fieldName] = f2;
    return f2;
  }

  FieldReflection<TestOpWithReflection, dynamic>? _fieldImpl(
      String fieldName, TestOpWithReflection? obj) {
    obj ??= object;

    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'type':
        return FieldReflection<TestOpWithReflection, String>(
          this,
          TestOpWithReflection,
          __TR.tString,
          'type',
          false,
          (o) => () => o!.type,
          null,
          obj,
          true,
        );
      case 'value':
        return FieldReflection<TestOpWithReflection, dynamic>(
          this,
          WithValue,
          __TR.tDynamic,
          'value',
          true,
          (o) => () => o!.value,
          (o) => (v) => o!.value = v,
          obj,
          false,
        );
      default:
        return null;
    }
  }

  @override
  Map<String, dynamic> getFieldsValues(TestOpWithReflection? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'type': obj?.type,
      'value': obj?.value,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  static const List<String> _staticFieldsNames = const <String>['staticField'];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  static final Map<String, StaticFieldReflection<TestOpWithReflection, dynamic>>
      _staticFields = {};

  @override
  StaticFieldReflection<TestOpWithReflection, T>? staticField<T>(
      String fieldName) {
    var f = _staticFields[fieldName];
    if (f != null) {
      return f as StaticFieldReflection<TestOpWithReflection, T>;
    }
    f = _staticFieldImpl(fieldName);
    if (f == null) return null;
    _staticFields[fieldName] = f;
    return f as StaticFieldReflection<TestOpWithReflection, T>;
  }

  StaticFieldReflection<TestOpWithReflection, dynamic>? _staticFieldImpl(
      String fieldName) {
    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'staticfield':
        return StaticFieldReflection<TestOpWithReflection, int>(
          this,
          TestOpWithReflection,
          __TR.tInt,
          'staticField',
          false,
          () => () => TestOpWithReflection.staticField,
          () => (v) => TestOpWithReflection.staticField = v,
          false,
          null,
        );
      default:
        return null;
    }
  }

  static const List<String> _methodsNames = const <String>['isEmptyType'];

  @override
  List<String> get methodsNames => _methodsNames;

  static final Map<String, MethodReflection<TestOpWithReflection, dynamic>>
      _methodsNoObject = {};

  final Map<String, MethodReflection<TestOpWithReflection, dynamic>>
      _methodsObject = {};

  @override
  MethodReflection<TestOpWithReflection, R>? method<R>(String methodName,
      [TestOpWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _methodObjectImpl<R>(methodName);
      } else {
        return _methodNoObjectImpl<R>(methodName);
      }
    } else if (identical(obj, object)) {
      return _methodObjectImpl<R>(methodName);
    }
    return _methodNoObjectImpl<R>(methodName)?.withObject(obj);
  }

  MethodReflection<TestOpWithReflection, R>? _methodNoObjectImpl<R>(
      String methodName) {
    final m = _methodsNoObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestOpWithReflection, R>;
    }
    final m2 = _methodImpl(methodName, null);
    if (m2 == null) return null;
    _methodsNoObject[methodName] = m2;
    return m2 as MethodReflection<TestOpWithReflection, R>;
  }

  MethodReflection<TestOpWithReflection, R>? _methodObjectImpl<R>(
      String methodName) {
    final m = _methodsObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestOpWithReflection, R>;
    }
    var m2 = _methodNoObjectImpl<R>(methodName);
    if (m2 == null) return null;
    m2 = m2.withObject(object!);
    _methodsObject[methodName] = m2;
    return m2;
  }

  MethodReflection<TestOpWithReflection, dynamic>? _methodImpl(
      String methodName, TestOpWithReflection? obj) {
    obj ??= object;

    var lc = methodName.trim().toLowerCase();

    switch (lc) {
      case 'isemptytype':
        return MethodReflection<TestOpWithReflection, bool>(
            this,
            TestOpWithReflection,
            'isEmptyType',
            __TR.tBool,
            false,
            (o) => o!.isEmptyType,
            obj,
            null,
            null,
            null,
            null);
      default:
        return null;
    }
  }

  static const List<String> _staticMethodsNames = const <String>[
    'staticMethod'
  ];

  @override
  List<String> get staticMethodsNames => _staticMethodsNames;

  static final Map<String,
          StaticMethodReflection<TestOpWithReflection, dynamic>>
      _staticMethods = {};

  @override
  StaticMethodReflection<TestOpWithReflection, R>? staticMethod<R>(
      String methodName) {
    var m = _staticMethods[methodName];
    if (m != null) {
      return m as StaticMethodReflection<TestOpWithReflection, R>;
    }
    m = _staticMethodImpl(methodName);
    if (m == null) return null;
    _staticMethods[methodName] = m;
    return m as StaticMethodReflection<TestOpWithReflection, R>;
  }

  StaticMethodReflection<TestOpWithReflection, dynamic>? _staticMethodImpl(
      String methodName) {
    var lc = methodName.trim().toLowerCase();

    switch (lc) {
      case 'staticmethod':
        return StaticMethodReflection<TestOpWithReflection, bool>(
            this,
            TestOpWithReflection,
            'staticMethod',
            __TR.tBool,
            false,
            () => TestOpWithReflection.staticMethod,
            null,
            null,
            null,
            null);
      default:
        return null;
    }
  }
}

class TestTransactionWithReflection$reflection
    extends ClassReflection<TestTransactionWithReflection>
    with __ReflectionMixin {
  static final Expando<TestTransactionWithReflection$reflection>
      _objectReflections = Expando();

  factory TestTransactionWithReflection$reflection(
      [TestTransactionWithReflection? object]) {
    if (object == null) return staticInstance;
    return _objectReflections[object] ??=
        TestTransactionWithReflection$reflection._(object);
  }

  TestTransactionWithReflection$reflection._(
      [TestTransactionWithReflection? object])
      : super(TestTransactionWithReflection, r'TestTransactionWithReflection',
            object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestTransactionWithReflection$reflection withObject(
          [TestTransactionWithReflection? obj]) =>
      TestTransactionWithReflection$reflection(obj)..setupInternalsWith(this);

  static TestTransactionWithReflection$reflection? _withoutObjectInstance;
  @override
  TestTransactionWithReflection$reflection withoutObjectInstance() =>
      staticInstance;

  static TestTransactionWithReflection$reflection get staticInstance =>
      _withoutObjectInstance ??= TestTransactionWithReflection$reflection._();

  @override
  TestTransactionWithReflection$reflection getStaticInstance() =>
      staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestTransactionWithReflection$reflection.staticInstance;
  }

  @override
  bool get hasDefaultConstructor => false;
  @override
  TestTransactionWithReflection? createInstanceWithDefaultConstructor() => null;

  @override
  bool get hasEmptyConstructor => false;
  @override
  TestTransactionWithReflection? createInstanceWithEmptyConstructor() => null;
  @override
  bool get hasNoRequiredArgsConstructor => false;
  @override
  TestTransactionWithReflection?
      createInstanceWithNoRequiredArgsConstructor() => null;

  static const List<String> _constructorsNames = const <String>['fromTo'];

  @override
  List<String> get constructorsNames => _constructorsNames;

  static final Map<String, ConstructorReflection<TestTransactionWithReflection>>
      _constructors = {};

  @override
  ConstructorReflection<TestTransactionWithReflection>? constructor(
      String constructorName) {
    var c = _constructors[constructorName];
    if (c != null) return c;
    c = _constructorImpl(constructorName);
    if (c == null) return null;
    _constructors[constructorName] = c;
    return c;
  }

  ConstructorReflection<TestTransactionWithReflection>? _constructorImpl(
      String constructorName) {
    var lc = constructorName.trim().toLowerCase();

    switch (lc) {
      case 'fromto':
        return ConstructorReflection<TestTransactionWithReflection>(
            this,
            TestTransactionWithReflection,
            'fromTo',
            () => (int amount, TestUserWithReflection fromUser,
                    TestUserWithReflection toUser) =>
                TestTransactionWithReflection.fromTo(amount, fromUser, toUser),
            const <__PR>[
              __PR(__TR.tInt, 'amount', false, true),
              __PR(__TR<TestUserWithReflection>(TestUserWithReflection),
                  'fromUser', false, true),
              __PR(__TR<TestUserWithReflection>(TestUserWithReflection),
                  'toUser', false, true)
            ],
            null,
            null,
            null);
      default:
        return null;
    }
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<Type> _supperTypes = const <Type>[];

  @override
  List<Type> get supperTypes => _supperTypes;

  @override
  bool get hasMethodToJson => false;

  @override
  Object? callMethodToJson([TestTransactionWithReflection? obj]) => null;

  static const List<String> _fieldsNames = const <String>[
    'amount',
    'fromUser',
    'toUser'
  ];

  @override
  List<String> get fieldsNames => _fieldsNames;

  static final Map<String,
          FieldReflection<TestTransactionWithReflection, dynamic>>
      _fieldsNoObject = {};

  final Map<String, FieldReflection<TestTransactionWithReflection, dynamic>>
      _fieldsObject = {};

  @override
  FieldReflection<TestTransactionWithReflection, T>? field<T>(String fieldName,
      [TestTransactionWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _fieldObjectImpl<T>(fieldName);
      } else {
        return _fieldNoObjectImpl<T>(fieldName);
      }
    } else if (identical(obj, object)) {
      return _fieldObjectImpl<T>(fieldName);
    }
    return _fieldNoObjectImpl<T>(fieldName)?.withObject(obj);
  }

  FieldReflection<TestTransactionWithReflection, T>? _fieldNoObjectImpl<T>(
      String fieldName) {
    final f = _fieldsNoObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestTransactionWithReflection, T>;
    }
    final f2 = _fieldImpl(fieldName, null);
    if (f2 == null) return null;
    _fieldsNoObject[fieldName] = f2;
    return f2 as FieldReflection<TestTransactionWithReflection, T>;
  }

  FieldReflection<TestTransactionWithReflection, T>? _fieldObjectImpl<T>(
      String fieldName) {
    final f = _fieldsObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestTransactionWithReflection, T>;
    }
    var f2 = _fieldNoObjectImpl<T>(fieldName);
    if (f2 == null) return null;
    f2 = f2.withObject(object!);
    _fieldsObject[fieldName] = f2;
    return f2;
  }

  FieldReflection<TestTransactionWithReflection, dynamic>? _fieldImpl(
      String fieldName, TestTransactionWithReflection? obj) {
    obj ??= object;

    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'fromuser':
        return FieldReflection<TestTransactionWithReflection,
            TestUserWithReflection>(
          this,
          TestTransactionWithReflection,
          __TR<TestUserWithReflection>(TestUserWithReflection),
          'fromUser',
          false,
          (o) => () => o!.fromUser,
          null,
          obj,
          true,
        );
      case 'touser':
        return FieldReflection<TestTransactionWithReflection,
            TestUserWithReflection>(
          this,
          TestTransactionWithReflection,
          __TR<TestUserWithReflection>(TestUserWithReflection),
          'toUser',
          false,
          (o) => () => o!.toUser,
          null,
          obj,
          true,
        );
      case 'amount':
        return FieldReflection<TestTransactionWithReflection, int>(
          this,
          TestTransactionWithReflection,
          __TR.tInt,
          'amount',
          false,
          (o) => () => o!.amount,
          null,
          obj,
          true,
        );
      default:
        return null;
    }
  }

  @override
  Map<String, dynamic> getFieldsValues(TestTransactionWithReflection? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'fromUser': obj?.fromUser,
      'toUser': obj?.toUser,
      'amount': obj?.amount,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  static const List<String> _staticFieldsNames = const <String>[];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  @override
  StaticFieldReflection<TestTransactionWithReflection, T>? staticField<T>(
          String fieldName) =>
      null;

  static const List<String> _methodsNames = const <String>[];

  @override
  List<String> get methodsNames => _methodsNames;

  @override
  MethodReflection<TestTransactionWithReflection, R>? method<R>(
          String methodName,
          [TestTransactionWithReflection? obj]) =>
      null;
  static const List<String> _staticMethodsNames = const <String>[];

  @override
  List<String> get staticMethodsNames => _staticMethodsNames;

  @override
  StaticMethodReflection<TestTransactionWithReflection, R>? staticMethod<R>(
          String methodName) =>
      null;
}

class TestUserWithReflection$reflection
    extends ClassReflection<TestUserWithReflection> with __ReflectionMixin {
  static final Expando<TestUserWithReflection$reflection> _objectReflections =
      Expando();

  factory TestUserWithReflection$reflection([TestUserWithReflection? object]) {
    if (object == null) return staticInstance;
    return _objectReflections[object] ??=
        TestUserWithReflection$reflection._(object);
  }

  TestUserWithReflection$reflection._([TestUserWithReflection? object])
      : super(TestUserWithReflection, r'TestUserWithReflection', object);

  static bool _registered = false;
  @override
  void register() {
    if (!_registered) {
      _registered = true;
      super.register();
      _registerSiblingsReflection();
    }
  }

  @override
  Version get languageVersion => Version.parse('3.3.0');

  @override
  TestUserWithReflection$reflection withObject([TestUserWithReflection? obj]) =>
      TestUserWithReflection$reflection(obj)..setupInternalsWith(this);

  static TestUserWithReflection$reflection? _withoutObjectInstance;
  @override
  TestUserWithReflection$reflection withoutObjectInstance() => staticInstance;

  static TestUserWithReflection$reflection get staticInstance =>
      _withoutObjectInstance ??= TestUserWithReflection$reflection._();

  @override
  TestUserWithReflection$reflection getStaticInstance() => staticInstance;

  static bool _boot = false;
  static void boot() {
    if (_boot) return;
    _boot = true;
    TestUserWithReflection$reflection.staticInstance;
  }

  @override
  bool get hasDefaultConstructor => true;
  @override
  TestUserWithReflection? createInstanceWithDefaultConstructor() =>
      TestUserWithReflection();

  @override
  bool get hasEmptyConstructor => false;
  @override
  TestUserWithReflection? createInstanceWithEmptyConstructor() => null;
  @override
  bool get hasNoRequiredArgsConstructor => false;
  @override
  TestUserWithReflection? createInstanceWithNoRequiredArgsConstructor() => null;

  static const List<String> _constructorsNames = const <String>['', 'fields'];

  @override
  List<String> get constructorsNames => _constructorsNames;

  static final Map<String, ConstructorReflection<TestUserWithReflection>>
      _constructors = {};

  @override
  ConstructorReflection<TestUserWithReflection>? constructor(
      String constructorName) {
    var c = _constructors[constructorName];
    if (c != null) return c;
    c = _constructorImpl(constructorName);
    if (c == null) return null;
    _constructors[constructorName] = c;
    return c;
  }

  ConstructorReflection<TestUserWithReflection>? _constructorImpl(
      String constructorName) {
    var lc = constructorName.trim().toLowerCase();

    switch (lc) {
      case 'fields':
        return ConstructorReflection<TestUserWithReflection>(
            this,
            TestUserWithReflection,
            'fields',
            () => (String name, String? email, String? passphrase,
                    {bool enabled = true,
                    TestEnumWithReflection axis = TestEnumWithReflection.x,
                    int? level,
                    int? id}) =>
                TestUserWithReflection.fields(name, email, passphrase,
                    enabled: enabled, axis: axis, level: level, id: id),
            const <__PR>[
              __PR(__TR.tString, 'name', false, true),
              __PR(__TR.tString, 'email', true, true),
              __PR(__TR.tString, 'passphrase', true, true, null,
                  const [JsonFieldAlias('password')])
            ],
            null,
            const <String, __PR>{
              'axis': __PR(__TR<TestEnumWithReflection>(TestEnumWithReflection),
                  'axis', false, false, TestEnumWithReflection.x),
              'enabled': __PR(__TR.tBool, 'enabled', false, false, true),
              'id': __PR(__TR.tInt, 'id', true, false),
              'level': __PR(__TR.tInt, 'level', true, false)
            },
            null);
      case '':
        return ConstructorReflection<TestUserWithReflection>(
            this,
            TestUserWithReflection,
            '',
            () => () => TestUserWithReflection(),
            null,
            null,
            null,
            null);
      default:
        return null;
    }
  }

  static const List<Object> _classAnnotations = <Object>[];

  @override
  List<Object> get classAnnotations => _classAnnotations;

  static const List<Type> _supperTypes = const <Type>[];

  @override
  List<Type> get supperTypes => _supperTypes;

  @override
  bool get hasMethodToJson => false;

  @override
  Object? callMethodToJson([TestUserWithReflection? obj]) => null;

  static const List<String> _fieldsNames = const <String>[
    'axis',
    'email',
    'enabled',
    'hashCode',
    'id',
    'isEnabled',
    'isNotEnabled',
    'level',
    'name',
    'password'
  ];

  @override
  List<String> get fieldsNames => _fieldsNames;

  static final Map<String, FieldReflection<TestUserWithReflection, dynamic>>
      _fieldsNoObject = {};

  final Map<String, FieldReflection<TestUserWithReflection, dynamic>>
      _fieldsObject = {};

  @override
  FieldReflection<TestUserWithReflection, T>? field<T>(String fieldName,
      [TestUserWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _fieldObjectImpl<T>(fieldName);
      } else {
        return _fieldNoObjectImpl<T>(fieldName);
      }
    } else if (identical(obj, object)) {
      return _fieldObjectImpl<T>(fieldName);
    }
    return _fieldNoObjectImpl<T>(fieldName)?.withObject(obj);
  }

  FieldReflection<TestUserWithReflection, T>? _fieldNoObjectImpl<T>(
      String fieldName) {
    final f = _fieldsNoObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestUserWithReflection, T>;
    }
    final f2 = _fieldImpl(fieldName, null);
    if (f2 == null) return null;
    _fieldsNoObject[fieldName] = f2;
    return f2 as FieldReflection<TestUserWithReflection, T>;
  }

  FieldReflection<TestUserWithReflection, T>? _fieldObjectImpl<T>(
      String fieldName) {
    final f = _fieldsObject[fieldName];
    if (f != null) {
      return f as FieldReflection<TestUserWithReflection, T>;
    }
    var f2 = _fieldNoObjectImpl<T>(fieldName);
    if (f2 == null) return null;
    f2 = f2.withObject(object!);
    _fieldsObject[fieldName] = f2;
    return f2;
  }

  FieldReflection<TestUserWithReflection, dynamic>? _fieldImpl(
      String fieldName, TestUserWithReflection? obj) {
    obj ??= object;

    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'id':
        return FieldReflection<TestUserWithReflection, int?>(
          this,
          TestUserWithReflection,
          __TR.tInt,
          'id',
          true,
          (o) => () => o!.id,
          (o) => (v) => o!.id = v,
          obj,
          false,
        );
      case 'name':
        return FieldReflection<TestUserWithReflection, String>(
          this,
          TestUserWithReflection,
          __TR.tString,
          'name',
          false,
          (o) => () => o!.name,
          null,
          obj,
          true,
        );
      case 'email':
        return FieldReflection<TestUserWithReflection, String?>(
          this,
          TestUserWithReflection,
          __TR.tString,
          'email',
          true,
          (o) => () => o!.email,
          (o) => (v) => o!.email = v,
          obj,
          false,
          const [JsonField.visible()],
        );
      case 'password':
        return FieldReflection<TestUserWithReflection, String?>(
          this,
          TestUserWithReflection,
          __TR.tString,
          'password',
          true,
          (o) => () => o!.password,
          (o) => (v) => o!.password = v,
          obj,
          false,
          const [JsonField.hidden()],
        );
      case 'enabled':
        return FieldReflection<TestUserWithReflection, bool>(
          this,
          TestUserWithReflection,
          __TR.tBool,
          'enabled',
          false,
          (o) => () => o!.enabled,
          (o) => (v) => o!.enabled = v,
          obj,
          false,
        );
      case 'axis':
        return FieldReflection<TestUserWithReflection, TestEnumWithReflection>(
          this,
          TestUserWithReflection,
          __TR<TestEnumWithReflection>(TestEnumWithReflection),
          'axis',
          false,
          (o) => () => o!.axis,
          (o) => (v) => o!.axis = v,
          obj,
          false,
        );
      case 'level':
        return FieldReflection<TestUserWithReflection, int?>(
          this,
          TestUserWithReflection,
          __TR.tInt,
          'level',
          true,
          (o) => () => o!.level,
          (o) => (v) => o!.level = v,
          obj,
          false,
          const [JsonFieldAlias('theLevel')],
        );
      case 'isenabled':
        return FieldReflection<TestUserWithReflection, bool>(
          this,
          TestUserWithReflection,
          __TR.tBool,
          'isEnabled',
          false,
          (o) => () => o!.isEnabled,
          null,
          obj,
          false,
          const [JsonField.visible()],
        );
      case 'isnotenabled':
        return FieldReflection<TestUserWithReflection, bool>(
          this,
          TestUserWithReflection,
          __TR.tBool,
          'isNotEnabled',
          false,
          (o) => () => o!.isNotEnabled,
          null,
          obj,
          false,
          const [JsonField.hidden()],
        );
      case 'hashcode':
        return FieldReflection<TestUserWithReflection, int>(
          this,
          TestUserWithReflection,
          __TR.tInt,
          'hashCode',
          false,
          (o) => () => o!.hashCode,
          null,
          obj,
          false,
          const [override],
        );
      default:
        return null;
    }
  }

  @override
  Map<String, dynamic> getFieldsValues(TestUserWithReflection? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'id': obj?.id,
      'name': obj?.name,
      'email': obj?.email,
      'password': obj?.password,
      'enabled': obj?.enabled,
      'axis': obj?.axis,
      'level': obj?.level,
      'isEnabled': obj?.isEnabled,
      'isNotEnabled': obj?.isNotEnabled,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  @override
  Map<String, dynamic> getJsonFieldsVisibleValues(TestUserWithReflection? obj,
      {bool withHashCode = false}) {
    obj ??= object;
    return <String, dynamic>{
      'id': obj?.id,
      'name': obj?.name,
      'email': obj?.email,
      'enabled': obj?.enabled,
      'axis': obj?.axis,
      'level': obj?.level,
      'isEnabled': obj?.isEnabled,
      if (withHashCode) 'hashCode': obj?.hashCode,
    };
  }

  static const List<String> _staticFieldsNames = const <String>[
    'version',
    'withReflection'
  ];

  @override
  List<String> get staticFieldsNames => _staticFieldsNames;

  static final Map<String,
          StaticFieldReflection<TestUserWithReflection, dynamic>>
      _staticFields = {};

  @override
  StaticFieldReflection<TestUserWithReflection, T>? staticField<T>(
      String fieldName) {
    var f = _staticFields[fieldName];
    if (f != null) {
      return f as StaticFieldReflection<TestUserWithReflection, T>;
    }
    f = _staticFieldImpl(fieldName);
    if (f == null) return null;
    _staticFields[fieldName] = f;
    return f as StaticFieldReflection<TestUserWithReflection, T>;
  }

  StaticFieldReflection<TestUserWithReflection, dynamic>? _staticFieldImpl(
      String fieldName) {
    var lc = fieldName.trim().toLowerCase();

    switch (lc) {
      case 'version':
        return StaticFieldReflection<TestUserWithReflection, double>(
          this,
          TestUserWithReflection,
          __TR.tDouble,
          'version',
          false,
          () => () => TestUserWithReflection.version,
          null,
          true,
          null,
        );
      case 'withreflection':
        return StaticFieldReflection<TestUserWithReflection, bool>(
          this,
          TestUserWithReflection,
          __TR.tBool,
          'withReflection',
          false,
          () => () => TestUserWithReflection.withReflection,
          null,
          true,
          null,
        );
      default:
        return null;
    }
  }

  static const List<String> _methodsNames = const <String>[
    'checkPassword',
    'getField',
    'setField',
    'toString'
  ];

  @override
  List<String> get methodsNames => _methodsNames;

  static final Map<String, MethodReflection<TestUserWithReflection, dynamic>>
      _methodsNoObject = {};

  final Map<String, MethodReflection<TestUserWithReflection, dynamic>>
      _methodsObject = {};

  @override
  MethodReflection<TestUserWithReflection, R>? method<R>(String methodName,
      [TestUserWithReflection? obj]) {
    if (obj == null) {
      if (object != null) {
        return _methodObjectImpl<R>(methodName);
      } else {
        return _methodNoObjectImpl<R>(methodName);
      }
    } else if (identical(obj, object)) {
      return _methodObjectImpl<R>(methodName);
    }
    return _methodNoObjectImpl<R>(methodName)?.withObject(obj);
  }

  MethodReflection<TestUserWithReflection, R>? _methodNoObjectImpl<R>(
      String methodName) {
    final m = _methodsNoObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestUserWithReflection, R>;
    }
    final m2 = _methodImpl(methodName, null);
    if (m2 == null) return null;
    _methodsNoObject[methodName] = m2;
    return m2 as MethodReflection<TestUserWithReflection, R>;
  }

  MethodReflection<TestUserWithReflection, R>? _methodObjectImpl<R>(
      String methodName) {
    final m = _methodsObject[methodName];
    if (m != null) {
      return m as MethodReflection<TestUserWithReflection, R>;
    }
    var m2 = _methodNoObjectImpl<R>(methodName);
    if (m2 == null) return null;
    m2 = m2.withObject(object!);
    _methodsObject[methodName] = m2;
    return m2;
  }

  MethodReflection<TestUserWithReflection, dynamic>? _methodImpl(
      String methodName, TestUserWithReflection? obj) {
    obj ??= object;

    var lc = methodName.trim().toLowerCase();

    switch (lc) {
      case 'checkpassword':
        return MethodReflection<TestUserWithReflection, bool>(
            this,
            TestUserWithReflection,
            'checkPassword',
            __TR.tBool,
            false,
            (o) => o!.checkPassword,
            obj,
            const <__PR>[__PR(__TR.tString, 'password', false, true)],
            null,
            null,
            null);
      case 'getfield':
        return MethodReflection<TestUserWithReflection, dynamic>(
            this,
            TestUserWithReflection,
            'getField',
            __TR.tDynamic,
            true,
            (o) => o!.getField,
            obj,
            const <__PR>[__PR(__TR.tString, 'key', false, true)],
            const <__PR>[__PR(__TR.tDynamic, 'def', true, false)],
            null,
            null);
      case 'setfield':
        return MethodReflection<TestUserWithReflection, void>(
            this,
            TestUserWithReflection,
            'setField',
            __TR.tVoid,
            false,
            (o) => o!.setField,
            obj,
            const <__PR>[
              __PR(__TR.tString, 'key', false, true),
              __PR(__TR.tDynamic, 'value', true, true)
            ],
            null,
            const <String, __PR>{
              'def': __PR(__TR.tDynamic, 'def', true, false)
            },
            null);
      case 'tostring':
        return MethodReflection<TestUserWithReflection, String>(
            this,
            TestUserWithReflection,
            'toString',
            __TR.tString,
            false,
            (o) => o!.toString,
            obj,
            null,
            null,
            null,
            const [override]);
      default:
        return null;
    }
  }

  static const List<String> _staticMethodsNames = const <String>['isVersion'];

  @override
  List<String> get staticMethodsNames => _staticMethodsNames;

  static final Map<String,
          StaticMethodReflection<TestUserWithReflection, dynamic>>
      _staticMethods = {};

  @override
  StaticMethodReflection<TestUserWithReflection, R>? staticMethod<R>(
      String methodName) {
    var m = _staticMethods[methodName];
    if (m != null) {
      return m as StaticMethodReflection<TestUserWithReflection, R>;
    }
    m = _staticMethodImpl(methodName);
    if (m == null) return null;
    _staticMethods[methodName] = m;
    return m as StaticMethodReflection<TestUserWithReflection, R>;
  }

  StaticMethodReflection<TestUserWithReflection, dynamic>? _staticMethodImpl(
      String methodName) {
    var lc = methodName.trim().toLowerCase();

    switch (lc) {
      case 'isversion':
        return StaticMethodReflection<TestUserWithReflection, bool>(
            this,
            TestUserWithReflection,
            'isVersion',
            __TR.tBool,
            false,
            () => TestUserWithReflection.isVersion,
            const <__PR>[__PR(__TR.tDouble, 'ver', false, true)],
            null,
            null,
            null);
      default:
        return null;
    }
  }
}

extension TestAddressWithReflection$reflectionExtension
    on TestAddressWithReflection {
  /// Returns a [ClassReflection] for type [TestAddressWithReflection]. (Generated by [ReflectionFactory])
  ClassReflection<TestAddressWithReflection> get reflection =>
      TestAddressWithReflection$reflection(this);

  /// Returns a JSON [Map] for type [TestAddressWithReflection]. (Generated by [ReflectionFactory])
  Map<String, dynamic>? toJsonMap({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonMap(duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns an encoded JSON [String] for type [TestAddressWithReflection]. (Generated by [ReflectionFactory])
  String toJsonEncoded(
          {bool pretty = false, bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonEncoded(
          pretty: pretty, duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns a JSON for type [TestAddressWithReflection] using the class fields. (Generated by [ReflectionFactory])
  Object? toJsonFromFields({bool duplicatedEntitiesAsID = false}) => reflection
      .toJsonFromFields(duplicatedEntitiesAsID: duplicatedEntitiesAsID);
}

extension TestCompanyWithReflection$reflectionExtension
    on TestCompanyWithReflection {
  /// Returns a [ClassReflection] for type [TestCompanyWithReflection]. (Generated by [ReflectionFactory])
  ClassReflection<TestCompanyWithReflection> get reflection =>
      TestCompanyWithReflection$reflection(this);

  /// Returns a JSON for type [TestCompanyWithReflection]. (Generated by [ReflectionFactory])
  Object? toJson({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJson(null, null, duplicatedEntitiesAsID);

  /// Returns a JSON [Map] for type [TestCompanyWithReflection]. (Generated by [ReflectionFactory])
  Map<String, dynamic>? toJsonMap({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonMap(duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns an encoded JSON [String] for type [TestCompanyWithReflection]. (Generated by [ReflectionFactory])
  String toJsonEncoded(
          {bool pretty = false, bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonEncoded(
          pretty: pretty, duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns a JSON for type [TestCompanyWithReflection] using the class fields. (Generated by [ReflectionFactory])
  Object? toJsonFromFields({bool duplicatedEntitiesAsID = false}) => reflection
      .toJsonFromFields(duplicatedEntitiesAsID: duplicatedEntitiesAsID);
}

extension TestDataWithReflection$reflectionExtension on TestDataWithReflection {
  /// Returns a [ClassReflection] for type [TestDataWithReflection]. (Generated by [ReflectionFactory])
  ClassReflection<TestDataWithReflection> get reflection =>
      TestDataWithReflection$reflection(this);

  /// Returns a JSON for type [TestDataWithReflection]. (Generated by [ReflectionFactory])
  Object? toJson({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJson(null, null, duplicatedEntitiesAsID);

  /// Returns a JSON [Map] for type [TestDataWithReflection]. (Generated by [ReflectionFactory])
  Map<String, dynamic>? toJsonMap({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonMap(duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns an encoded JSON [String] for type [TestDataWithReflection]. (Generated by [ReflectionFactory])
  String toJsonEncoded(
          {bool pretty = false, bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonEncoded(
          pretty: pretty, duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns a JSON for type [TestDataWithReflection] using the class fields. (Generated by [ReflectionFactory])
  Object? toJsonFromFields({bool duplicatedEntitiesAsID = false}) => reflection
      .toJsonFromFields(duplicatedEntitiesAsID: duplicatedEntitiesAsID);
}

extension TestDomainWithReflection$reflectionExtension
    on TestDomainWithReflection {
  /// Returns a [ClassReflection] for type [TestDomainWithReflection]. (Generated by [ReflectionFactory])
  ClassReflection<TestDomainWithReflection> get reflection =>
      TestDomainWithReflection$reflection(this);

  /// Returns a JSON [Map] for type [TestDomainWithReflection]. (Generated by [ReflectionFactory])
  Map<String, dynamic>? toJsonMap({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonMap(duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns an encoded JSON [String] for type [TestDomainWithReflection]. (Generated by [ReflectionFactory])
  String toJsonEncoded(
          {bool pretty = false, bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonEncoded(
          pretty: pretty, duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns a JSON for type [TestDomainWithReflection] using the class fields. (Generated by [ReflectionFactory])
  Object? toJsonFromFields({bool duplicatedEntitiesAsID = false}) => reflection
      .toJsonFromFields(duplicatedEntitiesAsID: duplicatedEntitiesAsID);
}

extension TestEmpty$reflectionExtension on TestEmpty {
  /// Returns a [ClassReflection] for type [TestEmpty]. (Generated by [ReflectionFactory])
  ClassReflection<TestEmpty> get reflection => TestEmpty$reflection(this);

  /// Returns a JSON for type [TestEmpty]. (Generated by [ReflectionFactory])
  Object? toJson({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJson(null, null, duplicatedEntitiesAsID);

  /// Returns a JSON [Map] for type [TestEmpty]. (Generated by [ReflectionFactory])
  Map<String, dynamic>? toJsonMap({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonMap(duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns an encoded JSON [String] for type [TestEmpty]. (Generated by [ReflectionFactory])
  String toJsonEncoded(
          {bool pretty = false, bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonEncoded(
          pretty: pretty, duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns a JSON for type [TestEmpty] using the class fields. (Generated by [ReflectionFactory])
  Object? toJsonFromFields({bool duplicatedEntitiesAsID = false}) => reflection
      .toJsonFromFields(duplicatedEntitiesAsID: duplicatedEntitiesAsID);
}

extension TestEnumWithReflection$reflectionExtension on TestEnumWithReflection {
  /// Returns a [EnumReflection] for type [TestEnumWithReflection]. (Generated by [ReflectionFactory])
  EnumReflection<TestEnumWithReflection> get reflection =>
      TestEnumWithReflection$reflection(this);

  /// Returns the name of the [TestEnumWithReflection] instance. (Generated by [ReflectionFactory])
  String get enumName => TestEnumWithReflection$reflection(this).name()!;

  /// Returns a JSON for type [TestEnumWithReflection]. (Generated by [ReflectionFactory])
  String? toJson() => reflection.toJson();

  /// Returns a JSON [Map] for type [TestEnumWithReflection]. (Generated by [ReflectionFactory])
  Map<String, Object>? toJsonMap() => reflection.toJsonMap();

  /// Returns an encoded JSON [String] for type [TestEnumWithReflection]. (Generated by [ReflectionFactory])
  String toJsonEncoded({bool pretty = false}) =>
      reflection.toJsonEncoded(pretty: pretty);
}

extension TestFranchiseWithReflection$reflectionExtension
    on TestFranchiseWithReflection {
  /// Returns a [ClassReflection] for type [TestFranchiseWithReflection]. (Generated by [ReflectionFactory])
  ClassReflection<TestFranchiseWithReflection> get reflection =>
      TestFranchiseWithReflection$reflection(this);

  /// Returns a JSON for type [TestFranchiseWithReflection]. (Generated by [ReflectionFactory])
  Object? toJson({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJson(null, null, duplicatedEntitiesAsID);

  /// Returns a JSON [Map] for type [TestFranchiseWithReflection]. (Generated by [ReflectionFactory])
  Map<String, dynamic>? toJsonMap({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonMap(duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns an encoded JSON [String] for type [TestFranchiseWithReflection]. (Generated by [ReflectionFactory])
  String toJsonEncoded(
          {bool pretty = false, bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonEncoded(
          pretty: pretty, duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns a JSON for type [TestFranchiseWithReflection] using the class fields. (Generated by [ReflectionFactory])
  Object? toJsonFromFields({bool duplicatedEntitiesAsID = false}) => reflection
      .toJsonFromFields(duplicatedEntitiesAsID: duplicatedEntitiesAsID);
}

extension TestName$reflectionExtension on TestName {
  /// Returns a [ClassReflection] for type [TestName]. (Generated by [ReflectionFactory])
  ClassReflection<TestName> get reflection => TestName$reflection(this);

  /// Returns a JSON for type [TestName]. (Generated by [ReflectionFactory])
  Object? toJson({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJson(null, null, duplicatedEntitiesAsID);

  /// Returns a JSON [Map] for type [TestName]. (Generated by [ReflectionFactory])
  Map<String, dynamic>? toJsonMap({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonMap(duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns an encoded JSON [String] for type [TestName]. (Generated by [ReflectionFactory])
  String toJsonEncoded(
          {bool pretty = false, bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonEncoded(
          pretty: pretty, duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns a JSON for type [TestName] using the class fields. (Generated by [ReflectionFactory])
  Object? toJsonFromFields({bool duplicatedEntitiesAsID = false}) => reflection
      .toJsonFromFields(duplicatedEntitiesAsID: duplicatedEntitiesAsID);
}

extension TestOpAWithReflection$reflectionExtension on TestOpAWithReflection {
  /// Returns a [ClassReflection] for type [TestOpAWithReflection]. (Generated by [ReflectionFactory])
  ClassReflection<TestOpAWithReflection> get reflection =>
      TestOpAWithReflection$reflection(this);

  /// Returns a JSON for type [TestOpAWithReflection]. (Generated by [ReflectionFactory])
  Object? toJson({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJson(null, null, duplicatedEntitiesAsID);

  /// Returns a JSON [Map] for type [TestOpAWithReflection]. (Generated by [ReflectionFactory])
  Map<String, dynamic>? toJsonMap({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonMap(duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns an encoded JSON [String] for type [TestOpAWithReflection]. (Generated by [ReflectionFactory])
  String toJsonEncoded(
          {bool pretty = false, bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonEncoded(
          pretty: pretty, duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns a JSON for type [TestOpAWithReflection] using the class fields. (Generated by [ReflectionFactory])
  Object? toJsonFromFields({bool duplicatedEntitiesAsID = false}) => reflection
      .toJsonFromFields(duplicatedEntitiesAsID: duplicatedEntitiesAsID);
}

extension TestOpBWithReflection$reflectionExtension on TestOpBWithReflection {
  /// Returns a [ClassReflection] for type [TestOpBWithReflection]. (Generated by [ReflectionFactory])
  ClassReflection<TestOpBWithReflection> get reflection =>
      TestOpBWithReflection$reflection(this);

  /// Returns a JSON for type [TestOpBWithReflection]. (Generated by [ReflectionFactory])
  Object? toJson({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJson(null, null, duplicatedEntitiesAsID);

  /// Returns a JSON [Map] for type [TestOpBWithReflection]. (Generated by [ReflectionFactory])
  Map<String, dynamic>? toJsonMap({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonMap(duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns an encoded JSON [String] for type [TestOpBWithReflection]. (Generated by [ReflectionFactory])
  String toJsonEncoded(
          {bool pretty = false, bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonEncoded(
          pretty: pretty, duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns a JSON for type [TestOpBWithReflection] using the class fields. (Generated by [ReflectionFactory])
  Object? toJsonFromFields({bool duplicatedEntitiesAsID = false}) => reflection
      .toJsonFromFields(duplicatedEntitiesAsID: duplicatedEntitiesAsID);
}

extension TestOpWithReflection$reflectionExtension on TestOpWithReflection {
  /// Returns a [ClassReflection] for type [TestOpWithReflection]. (Generated by [ReflectionFactory])
  ClassReflection<TestOpWithReflection> get reflection =>
      TestOpWithReflection$reflection(this);

  /// Returns a JSON for type [TestOpWithReflection]. (Generated by [ReflectionFactory])
  Object? toJson({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJson(null, null, duplicatedEntitiesAsID);

  /// Returns a JSON [Map] for type [TestOpWithReflection]. (Generated by [ReflectionFactory])
  Map<String, dynamic>? toJsonMap({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonMap(duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns an encoded JSON [String] for type [TestOpWithReflection]. (Generated by [ReflectionFactory])
  String toJsonEncoded(
          {bool pretty = false, bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonEncoded(
          pretty: pretty, duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns a JSON for type [TestOpWithReflection] using the class fields. (Generated by [ReflectionFactory])
  Object? toJsonFromFields({bool duplicatedEntitiesAsID = false}) => reflection
      .toJsonFromFields(duplicatedEntitiesAsID: duplicatedEntitiesAsID);
}

extension TestTransactionWithReflection$reflectionExtension
    on TestTransactionWithReflection {
  /// Returns a [ClassReflection] for type [TestTransactionWithReflection]. (Generated by [ReflectionFactory])
  ClassReflection<TestTransactionWithReflection> get reflection =>
      TestTransactionWithReflection$reflection(this);

  /// Returns a JSON for type [TestTransactionWithReflection]. (Generated by [ReflectionFactory])
  Object? toJson({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJson(null, null, duplicatedEntitiesAsID);

  /// Returns a JSON [Map] for type [TestTransactionWithReflection]. (Generated by [ReflectionFactory])
  Map<String, dynamic>? toJsonMap({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonMap(duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns an encoded JSON [String] for type [TestTransactionWithReflection]. (Generated by [ReflectionFactory])
  String toJsonEncoded(
          {bool pretty = false, bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonEncoded(
          pretty: pretty, duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns a JSON for type [TestTransactionWithReflection] using the class fields. (Generated by [ReflectionFactory])
  Object? toJsonFromFields({bool duplicatedEntitiesAsID = false}) => reflection
      .toJsonFromFields(duplicatedEntitiesAsID: duplicatedEntitiesAsID);
}

extension TestUserWithReflection$reflectionExtension on TestUserWithReflection {
  /// Returns a [ClassReflection] for type [TestUserWithReflection]. (Generated by [ReflectionFactory])
  ClassReflection<TestUserWithReflection> get reflection =>
      TestUserWithReflection$reflection(this);

  /// Returns a JSON for type [TestUserWithReflection]. (Generated by [ReflectionFactory])
  Object? toJson({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJson(null, null, duplicatedEntitiesAsID);

  /// Returns a JSON [Map] for type [TestUserWithReflection]. (Generated by [ReflectionFactory])
  Map<String, dynamic>? toJsonMap({bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonMap(duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns an encoded JSON [String] for type [TestUserWithReflection]. (Generated by [ReflectionFactory])
  String toJsonEncoded(
          {bool pretty = false, bool duplicatedEntitiesAsID = false}) =>
      reflection.toJsonEncoded(
          pretty: pretty, duplicatedEntitiesAsID: duplicatedEntitiesAsID);

  /// Returns a JSON for type [TestUserWithReflection] using the class fields. (Generated by [ReflectionFactory])
  Object? toJsonFromFields({bool duplicatedEntitiesAsID = false}) => reflection
      .toJsonFromFields(duplicatedEntitiesAsID: duplicatedEntitiesAsID);
}

List<Reflection> _listSiblingsReflection() => <Reflection>[
      TestUserWithReflection$reflection(),
      TestAddressWithReflection$reflection(),
      TestCompanyWithReflection$reflection(),
      TestFranchiseWithReflection$reflection(),
      TestDataWithReflection$reflection(),
      TestDomainWithReflection$reflection(),
      TestOpWithReflection$reflection(),
      TestOpAWithReflection$reflection(),
      TestOpBWithReflection$reflection(),
      TestTransactionWithReflection$reflection(),
      TestName$reflection(),
      TestEmpty$reflection(),
      TestEnumWithReflection$reflection(),
    ];

List<Reflection>? _siblingsReflectionList;
List<Reflection> _siblingsReflection() => _siblingsReflectionList ??=
    List<Reflection>.unmodifiable(_listSiblingsReflection());

bool _registerSiblingsReflectionCalled = false;
void _registerSiblingsReflection() {
  if (_registerSiblingsReflectionCalled) return;
  _registerSiblingsReflectionCalled = true;
  var length = _listSiblingsReflection().length;
  assert(length > 0);
}
